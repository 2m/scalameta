### Internal structure of scala.meta ASTs

We use macro annotations to generate swaths of boilerplate that make our abstract syntax trees efficient and convenient.
Here's the code that we write in [Trees.scala](/scalameta/trees/src/main/scala/scala/meta/Trees.scala):

```
@ast class If(cond: Term, thenp: Term, elsep: Term) extends Term
```

Here's the code generated by the `@ast` macro annotation:

```
@new _root_.scala.meta.internal.ast.Metadata.astClass() @new _root_.org.scalameta.adt.Metadata.leafClass() abstract trait If extends Term with _root_.scala.Product {
  @new _root_.scala.meta.internal.ast.Metadata.astField() def cond: Term;
  @new _root_.scala.meta.internal.ast.Metadata.astField() def thenp: Term;
  @new _root_.scala.meta.internal.ast.Metadata.astField() def elsep: Term;
  def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep): If
}
@new _root_.scala.meta.internal.ast.Metadata.astCompanion() @new _root_.org.scalameta.adt.Metadata.leafCompanion() object If extends scala.AnyRef {
  def <init>() = {
    super.<init>();
    ()
  };
  private object sharedClassifier extends _root_.scala.meta.classifiers.Classifier[_root_.scala.meta.Tree, If] {
    def <init>() = {
      super.<init>();
      ()
    };
    def apply(x: _root_.scala.meta.Tree): Boolean = x.isInstanceOf[If]
  };
  implicit def ClassifierClass[T <: _root_.scala.meta.Tree]: _root_.scala.meta.classifiers.Classifier[T, If] = sharedClassifier.asInstanceOf[_root_.scala.meta.classifiers.Classifier[T, If]];
  def apply(cond: Term, thenp: Term, elsep: Term): If = {
    def internal(cond: Term, thenp: Term, elsep: Term): If = {
      _root_.scala.meta.internal.ast.CommonTyperMacros.hierarchyCheck[If];
      _root_.org.scalameta.data.DataTyperMacros.nullCheck(cond);
      _root_.org.scalameta.data.DataTyperMacros.nullCheck(thenp);
      _root_.org.scalameta.data.DataTyperMacros.nullCheck(elsep);
      _root_.org.scalameta.data.DataTyperMacros.emptyCheck(cond);
      _root_.org.scalameta.data.DataTyperMacros.emptyCheck(thenp);
      _root_.org.scalameta.data.DataTyperMacros.emptyCheck(elsep);
      val node = new TermIfImpl(_root_.scala.meta.internal.flags.ZERO, null, null, null, null, null)(_root_.scala.meta.internal.ast.CommonTyperMacros.initParam(cond), _root_.scala.meta.internal.ast.CommonTyperMacros.initParam(thenp), _root_.scala.meta.internal.ast.CommonTyperMacros.initParam(elsep));
      _root_.scala.meta.internal.ast.CommonTyperMacros.storeField(node._cond, cond);
      _root_.scala.meta.internal.ast.CommonTyperMacros.storeField(node._thenp, thenp);
      _root_.scala.meta.internal.ast.CommonTyperMacros.storeField(node._elsep, elsep);
      node
    };
    internal(cond, thenp, elsep)
  };
  @new _root_.scala.inline() final def unapply(x: If): _root_.scala.Option[scala.Tuple3[Term, Term, Term]] = if (x.$eq$eq(null))
    _root_.scala.None
  else
    _root_.scala.Some(scala.Tuple3(x.cond, x.thenp, x.elsep));
  @new _root_.scala.meta.internal.ast.ast() private[meta] class Quasi extends If with _root_.scala.meta.internal.ast.Quasi with Term.Quasi {
    <paramaccessor> private[this] val rank: _root_.scala.Int = _;
    <paramaccessor> private[this] val tree: _root_.scala.meta.Tree = _;
    def <init>(rank: _root_.scala.Int, tree: _root_.scala.meta.Tree) = {
      super.<init>();
      ()
    };
    def pt: _root_.java.lang.Class[_$42] forSome {
      <synthetic> type _$42
    } = _root_.scala.meta.internal.ast.Helpers.arrayClass(_root_.scala.Predef.classOf[If], this.rank);
    def cond: _root_.scala.Nothing = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def thenp: _root_.scala.Nothing = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def elsep: _root_.scala.Nothing = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def name: _root_.scala.Nothing = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def value: _root_.scala.Nothing = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep): If = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position")
  };
  @new _root_.scala.SerialVersionUID(1L) final private[If] class TermIfImpl extends If {
    <paramaccessor> private[meta] val privateFlags: _root_.scala.meta.internal.flags.Flags = _;
    @new _root_.scala.transient() <paramaccessor> private[meta] val privatePrototype: If = _;
    <paramaccessor> private[meta] val privateParent: _root_.scala.meta.Tree = _;
    <paramaccessor> private[meta] val privateOrigin: _root_.scala.meta.internal.ast.Origin = _;
    override <paramaccessor> private[meta] val privateEnv: _root_.scala.meta.internal.semantic.Environment = _;
    override <paramaccessor> private[meta] val privateTyping: _root_.scala.meta.internal.semantic.Typing = _;
    <paramaccessor> var _cond: Term = _;
    <paramaccessor> var _thenp: Term = _;
    <paramaccessor> var _elsep: Term = _;
    def <init>(privateFlags: _root_.scala.meta.internal.flags.Flags, @new _root_.scala.transient() privatePrototype: If, privateParent: _root_.scala.meta.Tree, privateOrigin: _root_.scala.meta.internal.ast.Origin, privateEnv: _root_.scala.meta.internal.semantic.Environment, privateTyping: _root_.scala.meta.internal.semantic.Typing)(_cond: Term, _thenp: Term, _elsep: Term) = {
      super.<init>();
      ()
    };
    def cond: Term = {
      _root_.scala.meta.internal.ast.CommonTyperMacros.loadField(this._cond);
      this._cond
    };
    def thenp: Term = {
      _root_.scala.meta.internal.ast.CommonTyperMacros.loadField(this._thenp);
      this._thenp
    };
    def elsep: Term = {
      _root_.scala.meta.internal.ast.CommonTyperMacros.loadField(this._elsep);
      this._elsep
    };
    private[meta] def privateCopy(flags: _root_.scala.meta.internal.flags.Flags = privateFlags, prototype: _root_.scala.meta.Tree = this, parent: _root_.scala.meta.Tree = privateParent, origin: _root_.scala.meta.internal.ast.Origin = privateOrigin, env: _root_.scala.meta.internal.semantic.Environment = privateEnv, denot: _root_.scala.meta.internal.semantic.Denotation = privateDenot, typing: _root_.scala.meta.internal.semantic.Typing = privateTyping): Tree = new TermIfImpl(flags, prototype.asInstanceOf[If], parent, origin, env, typing)(_root_.scala.meta.internal.ast.CommonTyperMacros.initField(this._cond), _root_.scala.meta.internal.ast.CommonTyperMacros.initField(this._thenp), _root_.scala.meta.internal.ast.CommonTyperMacros.initField(this._elsep));
    def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep): If = If.apply(cond, thenp, elsep);
    def children: Seq[_root_.scala.meta.Tree] = _root_.scala.meta.internal.ast.CommonTyperMacros.children[If, _root_.scala.meta.Tree];
    override def productPrefix: _root_.scala.Predef.String = _root_.scala.meta.internal.ast.CommonTyperMacros.productPrefix[If];
    override def productArity: _root_.scala.Int = 3;
    override def productElement(n: _root_.scala.Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
    };
    override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this);
    protected def writeReplace(): _root_.scala.AnyRef = {
      _root_.scala.meta.internal.ast.CommonTyperMacros.loadField(this._cond);
      _root_.scala.meta.internal.ast.CommonTyperMacros.loadField(this._thenp);
      _root_.scala.meta.internal.ast.CommonTyperMacros.loadField(this._elsep);
      this
    }
  }
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@meta.internal.ast.Metadata.astClass @org.scalameta.adt.Metadata.leafClass abstract trait If extends AnyRef with scala.meta.Term with Product {
  @meta.internal.ast.Metadata.astField def cond: scala.meta.Term;
  @meta.internal.ast.Metadata.astField def thenp: scala.meta.Term;
  @meta.internal.ast.Metadata.astField def elsep: scala.meta.Term;
  def copy(cond: scala.meta.Term = this.cond, thenp: scala.meta.Term = this.thenp, elsep: scala.meta.Term = this.elsep): scala.meta.Term.If;
  <synthetic> def copy$default$1: scala.meta.Term = this.cond;
  <synthetic> def copy$default$2: scala.meta.Term = this.thenp;
  <synthetic> def copy$default$3: scala.meta.Term = this.elsep
};
@@<?> @@<?> object If extends scala.AnyRef with Serializable {
  def <init>(): scala.meta.Term.If.type = {
    If.super.<init>();
    ()
  };
  private object sharedClassifier extends AnyRef with scala.meta.classifiers.Classifier[scala.meta.Tree,scala.meta.Term.If] {
    def <init>(): scala.meta.Term.If.sharedClassifier.type = {
      sharedClassifier.super.<init>();
      ()
    };
    def apply(x: scala.meta.Tree): Boolean = x.isInstanceOf[scala.meta.Term.If]
  };
  implicit def ClassifierClass[T <: scala.meta.Tree]: scala.meta.classifiers.Classifier[T,scala.meta.Term.If] = If.this.sharedClassifier.asInstanceOf[scala.meta.classifiers.Classifier[T,scala.meta.Term.If]];
  def apply(cond: scala.meta.Term, thenp: scala.meta.Term, elsep: scala.meta.Term): scala.meta.Term.If = {
    def internal(cond: scala.meta.Term, thenp: scala.meta.Term, elsep: scala.meta.Term): scala.meta.Term.If = {
      ((): Unit);
      (({
        val result$macro$292: Boolean = cond.!=(null);
        if (result$macro$292)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("cond is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$291 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("cond.!=(null)", failures$macro$291, scala.collection.immutable.Map.apply[String, scala.meta.Term](scala.Tuple2.apply[String, scala.meta.Term]("cond", cond)))
      }: Unit): Unit);
      (({
        val result$macro$294: Boolean = thenp.!=(null);
        if (result$macro$294)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("thenp is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$293 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("thenp.!=(null)", failures$macro$293, scala.collection.immutable.Map.apply[String, scala.meta.Term](scala.Tuple2.apply[String, scala.meta.Term]("thenp", thenp)))
      }: Unit): Unit);
      (({
        val result$macro$296: Boolean = elsep.!=(null);
        if (result$macro$296)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("elsep is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$295 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("elsep.!=(null)", failures$macro$295, scala.collection.immutable.Map.apply[String, scala.meta.Term](scala.Tuple2.apply[String, scala.meta.Term]("elsep", elsep)))
      }: Unit): Unit);
      ((): Unit);
      ((): Unit);
      ((): Unit);
      val node: scala.meta.Term.If.TermIfImpl = new If.this.TermIfImpl(scala.meta.internal.flags.`package`.ZERO, null, null, null, null, null)((null: scala.meta.Term), (null: scala.meta.Term), (null: scala.meta.Term));
      (node._cond_=({
<artifact> val x$1228: scala.meta.Term = cond;
<artifact> val x$1229: scala.meta.Term.If.TermIfImpl = node;
<artifact> val x$1230: meta.internal.flags.Flags = cond.privateCopy$default$1;
<artifact> val x$1231: scala.meta.internal.ast.Origin = cond.privateCopy$default$4;
<artifact> val x$1232: scala.meta.internal.semantic.Environment = cond.privateCopy$default$5;
<artifact> val x$1233: scala.meta.internal.semantic.Denotation = cond.privateCopy$default$6;
<artifact> val x$1234: scala.meta.internal.semantic.Typing = cond.privateCopy$default$7;
cond.privateCopy(x$1230, x$1228, x$1229, x$1231, x$1232, x$1233, x$1234)
}.asInstanceOf[scala.meta.Term]): Unit);
      (node._thenp_=({
<artifact> val x$1235: scala.meta.Term = thenp;
<artifact> val x$1236: scala.meta.Term.If.TermIfImpl = node;
<artifact> val x$1237: meta.internal.flags.Flags = thenp.privateCopy$default$1;
<artifact> val x$1238: scala.meta.internal.ast.Origin = thenp.privateCopy$default$4;
<artifact> val x$1239: scala.meta.internal.semantic.Environment = thenp.privateCopy$default$5;
<artifact> val x$1240: scala.meta.internal.semantic.Denotation = thenp.privateCopy$default$6;
<artifact> val x$1241: scala.meta.internal.semantic.Typing = thenp.privateCopy$default$7;
thenp.privateCopy(x$1237, x$1235, x$1236, x$1238, x$1239, x$1240, x$1241)
}.asInstanceOf[scala.meta.Term]): Unit);
      (node._elsep_=({
<artifact> val x$1242: scala.meta.Term = elsep;
<artifact> val x$1243: scala.meta.Term.If.TermIfImpl = node;
<artifact> val x$1244: meta.internal.flags.Flags = elsep.privateCopy$default$1;
<artifact> val x$1245: scala.meta.internal.ast.Origin = elsep.privateCopy$default$4;
<artifact> val x$1246: scala.meta.internal.semantic.Environment = elsep.privateCopy$default$5;
<artifact> val x$1247: scala.meta.internal.semantic.Denotation = elsep.privateCopy$default$6;
<artifact> val x$1248: scala.meta.internal.semantic.Typing = elsep.privateCopy$default$7;
elsep.privateCopy(x$1244, x$1242, x$1243, x$1245, x$1246, x$1247, x$1248)
}.asInstanceOf[scala.meta.Term]): Unit);
      node
    };
    internal(cond, thenp, elsep)
  };
  @inline final def unapply(x: scala.meta.Term.If): Option[(scala.meta.Term, scala.meta.Term, scala.meta.Term)] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[(scala.meta.Term, scala.meta.Term, scala.meta.Term)](scala.Tuple3.apply[scala.meta.Term, scala.meta.Term, scala.meta.Term](x.cond, x.thenp, x.elsep));
  @meta.internal.ast.Metadata.astClass @org.scalameta.adt.Metadata.leafClass abstract private[meta] trait Quasi extends AnyRef with scala.meta.Term.If with scala.meta.internal.ast.Quasi with scala.meta.Term.Quasi with Product {
    @meta.internal.ast.Metadata.astField def rank: Int;
    @meta.internal.ast.Metadata.astField def tree: scala.meta.Tree
  };
  @@<?> @@<?> private[meta] object Quasi extends scala.AnyRef with Serializable {
    def <init>(): scala.meta.Term.If.Quasi.type = {
      Quasi.super.<init>();
      ()
    };
    private object sharedClassifier extends AnyRef with scala.meta.classifiers.Classifier[scala.meta.Tree,scala.meta.Term.If.Quasi] {
      def <init>(): scala.meta.Term.If.Quasi.sharedClassifier.type = {
        sharedClassifier.super.<init>();
        ()
      };
      def apply(x: scala.meta.Tree): Boolean = x.isInstanceOf[scala.meta.Term.If.Quasi]
    };
    implicit def ClassifierClass[T <: scala.meta.Tree]: scala.meta.classifiers.Classifier[T,scala.meta.Term.If.Quasi] = Quasi.this.sharedClassifier.asInstanceOf[scala.meta.classifiers.Classifier[T,scala.meta.Term.If.Quasi]];
    def apply(rank: Int, tree: scala.meta.Tree): scala.meta.Term.If.Quasi = {
      def internal(rank: Int, tree: scala.meta.Tree): scala.meta.Term.If.Quasi = {
        ((): Unit);
        ((): Unit);
        (({
          val result$macro$298: Boolean = tree.!=(null);
          if (result$macro$298)
            scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
          else
            scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("tree is equal to null"))
        } match {
          case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
          case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$297 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("tree.!=(null)", failures$macro$297, scala.collection.immutable.Map.apply[String, scala.meta.Tree](scala.Tuple2.apply[String, scala.meta.Tree]("tree", tree)))
        }: Unit): Unit);
        ((): Unit);
        ((): Unit);
        val node: scala.meta.Term.If.Quasi.TermIfQuasiImpl = new Quasi.this.TermIfQuasiImpl(scala.meta.internal.flags.`package`.ZERO, null, null, null)((rank: Int), (null: scala.meta.Tree));
        ((): Unit);
        (node._tree_=({
<artifact> val x$1249: scala.meta.Tree = tree;
<artifact> val x$1250: scala.meta.Term.If.Quasi.TermIfQuasiImpl = node;
<artifact> val x$1251: meta.internal.flags.Flags = tree.privateCopy$default$1;
<artifact> val x$1252: scala.meta.internal.ast.Origin = tree.privateCopy$default$4;
<artifact> val x$1253: scala.meta.internal.semantic.Environment = tree.privateCopy$default$5;
<artifact> val x$1254: scala.meta.internal.semantic.Denotation = tree.privateCopy$default$6;
<artifact> val x$1255: scala.meta.internal.semantic.Typing = tree.privateCopy$default$7;
tree.privateCopy(x$1251, x$1249, x$1250, x$1252, x$1253, x$1254, x$1255)
}.asInstanceOf[scala.meta.Tree]): Unit);
        node
      };
      internal(rank, tree)
    };
    @inline final def unapply(x: scala.meta.Term.If.Quasi): Option[(Int, scala.meta.Tree)] = if (x.==(null))
      scala.None
    else
      scala.Some.apply[(Int, scala.meta.Tree)](scala.Tuple2.apply[Int, scala.meta.Tree](x.rank, x.tree));
    @SerialVersionUID(value = 1L) final private[Quasi] class TermIfQuasiImpl extends AnyRef with scala.meta.Term.If.Quasi {
      <paramaccessor> private[this] val privateFlags: meta.internal.flags.Flags = _;
      <stable> <accessor> <paramaccessor> private[meta] def privateFlags: meta.internal.flags.Flags = TermIfQuasiImpl.this.privateFlags;
      @transient <paramaccessor> private[this] val privatePrototype: scala.meta.Term.If.Quasi = _;
      <stable> <accessor> <paramaccessor> private[meta] def privatePrototype: scala.meta.Term.If.Quasi = TermIfQuasiImpl.this.privatePrototype;
      <paramaccessor> private[this] val privateParent: scala.meta.Tree = _;
      <stable> <accessor> <paramaccessor> private[meta] def privateParent: scala.meta.Tree = TermIfQuasiImpl.this.privateParent;
      <paramaccessor> private[this] val privateOrigin: scala.meta.internal.ast.Origin = _;
      <stable> <accessor> <paramaccessor> private[meta] def privateOrigin: scala.meta.internal.ast.Origin = TermIfQuasiImpl.this.privateOrigin;
      <paramaccessor> private[this] var _rank: Int = _;
      <accessor> <paramaccessor> def _rank: Int = TermIfQuasiImpl.this._rank;
      <accessor> <paramaccessor> def _rank_=(x$1: Int): Unit = TermIfQuasiImpl.this._rank = x$1;
      <paramaccessor> private[this] var _tree: scala.meta.Tree = _;
      <accessor> <paramaccessor> def _tree: scala.meta.Tree = TermIfQuasiImpl.this._tree;
      <accessor> <paramaccessor> def _tree_=(x$1: scala.meta.Tree): Unit = TermIfQuasiImpl.this._tree = x$1;
      def <init>(privateFlags: meta.internal.flags.Flags, privatePrototype: scala.meta.Term.If.Quasi, privateParent: scala.meta.Tree, privateOrigin: scala.meta.internal.ast.Origin)(_rank: Int, _tree: scala.meta.Tree): scala.meta.Term.If.Quasi.TermIfQuasiImpl = {
        TermIfQuasiImpl.super.<init>();
        ()
      };
      def pt: Class[_] = scala.meta.internal.ast.Helpers.arrayClass(classOf[scala.meta.Term$$If], this.rank);
      def cond: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def thenp: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def elsep: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def name: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def value: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def copy(cond: scala.meta.Term = this.cond, thenp: scala.meta.Term = this.thenp, elsep: scala.meta.Term = this.elsep): scala.meta.Term.If = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override <synthetic> def copy$default$1: scala.meta.Term = this.cond;
      override <synthetic> def copy$default$2: scala.meta.Term = this.thenp;
      override <synthetic> def copy$default$3: scala.meta.Term = this.elsep;
      def rank: Int = {
        ((): Unit);
        this._rank
      };
      def tree: scala.meta.Tree = {
        (if (this._tree.==(null))
          {
            scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfQuasiImpl.tree");
            this._tree_=({
              val copyTree$macro$299: scala.meta.Tree = {
<artifact> val qual$95: scala.meta.Tree = this.privatePrototype.tree;
<artifact> val x$1256: scala.meta.Tree = this.privatePrototype.tree;
<artifact> val x$1257: scala.meta.Term.If.Quasi.TermIfQuasiImpl = this;
<artifact> val x$1258: meta.internal.flags.Flags = qual$95.privateCopy$default$1;
<artifact> val x$1259: scala.meta.internal.ast.Origin = qual$95.privateCopy$default$4;
<artifact> val x$1260: scala.meta.internal.semantic.Environment = qual$95.privateCopy$default$5;
<artifact> val x$1261: scala.meta.internal.semantic.Denotation = qual$95.privateCopy$default$6;
<artifact> val x$1262: scala.meta.internal.semantic.Typing = qual$95.privateCopy$default$7;
qual$95.privateCopy(x$1258, x$1256, x$1257, x$1259, x$1260, x$1261, x$1262)
}.asInstanceOf[scala.meta.Tree];
              if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Quasi](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Quasi.TermIfQuasiImpl](this).isTypechecked))
                meta.this.Tree.XtensionTypecheckableTree[scala.meta.Tree](copyTree$macro$299).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Quasi.TermIfQuasiImpl](this).isTypechecked)
              else
                copyTree$macro$299
            })
          }
        else
          (): Unit);
        this._tree
      };
      private[meta] def privateCopy(flags: meta.internal.flags.Flags = TermIfQuasiImpl.this.privateFlags, prototype: scala.meta.Tree = this, parent: scala.meta.Tree = TermIfQuasiImpl.this.privateParent, origin: scala.meta.internal.ast.Origin = TermIfQuasiImpl.this.privateOrigin, env: scala.meta.internal.semantic.Environment = TermIfQuasiImpl.this.privateEnv, denot: scala.meta.internal.semantic.Denotation = TermIfQuasiImpl.this.privateDenot, typing: scala.meta.internal.semantic.Typing = TermIfQuasiImpl.this.privateTyping): scala.meta.Tree = new Quasi.this.TermIfQuasiImpl(flags, prototype.asInstanceOf[scala.meta.Term.If.Quasi], parent, origin)((this._rank: Int), (null: scala.meta.Tree));
      override <synthetic> def privateCopy$default$1: meta.internal.flags.Flags = TermIfQuasiImpl.this.privateFlags;
      override <synthetic> def privateCopy$default$2: scala.meta.Tree = this;
      override <synthetic> def privateCopy$default$3: scala.meta.Tree = TermIfQuasiImpl.this.privateParent;
      override <synthetic> def privateCopy$default$4: scala.meta.internal.ast.Origin = TermIfQuasiImpl.this.privateOrigin;
      override <synthetic> def privateCopy$default$5: scala.meta.internal.semantic.Environment = TermIfQuasiImpl.this.privateEnv;
      override <synthetic> def privateCopy$default$6: scala.meta.internal.semantic.Denotation = TermIfQuasiImpl.this.privateDenot;
      override <synthetic> def privateCopy$default$7: scala.meta.internal.semantic.Typing = TermIfQuasiImpl.this.privateTyping;
      def children: scala.collection.immutable.Seq[scala.meta.Tree] = (scala.collection.immutable.List.apply[scala.meta.Tree](this.tree): scala.collection.immutable.Seq[scala.meta.Tree]);
      override def productPrefix: String = ("Term.If.Quasi": String);
      override def productArity: Int = 2;
      override def productElement(n: Int): Any = n match {
        case 0 => this.rank
        case 1 => this.tree
        case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
      };
      override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this);
      protected def writeReplace(): AnyRef = {
        ((): Unit);
        (if (this._tree.==(null))
          {
            scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfQuasiImpl.tree");
            this._tree_=({
              val copyTree$macro$300: scala.meta.Tree = {
<artifact> val qual$96: scala.meta.Tree = this.privatePrototype.tree;
<artifact> val x$1263: scala.meta.Tree = this.privatePrototype.tree;
<artifact> val x$1264: scala.meta.Term.If.Quasi.TermIfQuasiImpl = this;
<artifact> val x$1265: meta.internal.flags.Flags = qual$96.privateCopy$default$1;
<artifact> val x$1266: scala.meta.internal.ast.Origin = qual$96.privateCopy$default$4;
<artifact> val x$1267: scala.meta.internal.semantic.Environment = qual$96.privateCopy$default$5;
<artifact> val x$1268: scala.meta.internal.semantic.Denotation = qual$96.privateCopy$default$6;
<artifact> val x$1269: scala.meta.internal.semantic.Typing = qual$96.privateCopy$default$7;
qual$96.privateCopy(x$1265, x$1263, x$1264, x$1266, x$1267, x$1268, x$1269)
}.asInstanceOf[scala.meta.Tree];
              if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Quasi](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Quasi.TermIfQuasiImpl](this).isTypechecked))
                meta.this.Tree.XtensionTypecheckableTree[scala.meta.Tree](copyTree$macro$300).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Quasi.TermIfQuasiImpl](this).isTypechecked)
              else
                copyTree$macro$300
            })
          }
        else
          (): Unit);
        this
      };
      def become[T <: scala.meta.internal.ast.Quasi](implicit ev: scala.meta.internal.ast.AstInfo[T]): T = this match {
        case If.this.Quasi.unapply(<unapply-selector>) <unapply> (0, (tree @ _)) => meta.this.Tree.XtensionOriginTree[T](ev.quasi(0, tree)).withOrigin(this.origin).asInstanceOf[T]
        case If.this.Quasi.unapply(<unapply-selector>) <unapply> (1, (nested @ If.this.Quasi.unapply(<unapply-selector>) <unapply> (0, (tree @ _)))) => meta.this.Tree.XtensionOriginTree[T](ev.quasi(1, nested.become[T](ev))).withOrigin(this.origin).asInstanceOf[T]
        case _ => throw new scala.`package`.Exception("complex ellipses are not supported yet")
      }
    };
    <synthetic> private def readResolve(): Object = If.this.Quasi
  };
  @SerialVersionUID(value = 1L) final private[If] class TermIfImpl extends AnyRef with scala.meta.Term.If {
    <paramaccessor> private[this] val privateFlags: meta.internal.flags.Flags = _;
    <stable> <accessor> <paramaccessor> private[meta] def privateFlags: meta.internal.flags.Flags = TermIfImpl.this.privateFlags;
    @transient <paramaccessor> private[this] val privatePrototype: scala.meta.Term.If = _;
    <stable> <accessor> <paramaccessor> private[meta] def privatePrototype: scala.meta.Term.If = TermIfImpl.this.privatePrototype;
    <paramaccessor> private[this] val privateParent: scala.meta.Tree = _;
    <stable> <accessor> <paramaccessor> private[meta] def privateParent: scala.meta.Tree = TermIfImpl.this.privateParent;
    <paramaccessor> private[this] val privateOrigin: scala.meta.internal.ast.Origin = _;
    <stable> <accessor> <paramaccessor> private[meta] def privateOrigin: scala.meta.internal.ast.Origin = TermIfImpl.this.privateOrigin;
    <paramaccessor> private[this] val privateEnv: scala.meta.internal.semantic.Environment = _;
    override <stable> <accessor> <paramaccessor> private[meta] def privateEnv: scala.meta.internal.semantic.Environment = TermIfImpl.this.privateEnv;
    <paramaccessor> private[this] val privateTyping: scala.meta.internal.semantic.Typing = _;
    override <stable> <accessor> <paramaccessor> private[meta] def privateTyping: scala.meta.internal.semantic.Typing = TermIfImpl.this.privateTyping;
    <paramaccessor> private[this] var _cond: scala.meta.Term = _;
    <accessor> <paramaccessor> def _cond: scala.meta.Term = TermIfImpl.this._cond;
    <accessor> <paramaccessor> def _cond_=(x$1: scala.meta.Term): Unit = TermIfImpl.this._cond = x$1;
    <paramaccessor> private[this] var _thenp: scala.meta.Term = _;
    <accessor> <paramaccessor> def _thenp: scala.meta.Term = TermIfImpl.this._thenp;
    <accessor> <paramaccessor> def _thenp_=(x$1: scala.meta.Term): Unit = TermIfImpl.this._thenp = x$1;
    <paramaccessor> private[this] var _elsep: scala.meta.Term = _;
    <accessor> <paramaccessor> def _elsep: scala.meta.Term = TermIfImpl.this._elsep;
    <accessor> <paramaccessor> def _elsep_=(x$1: scala.meta.Term): Unit = TermIfImpl.this._elsep = x$1;
    def <init>(privateFlags: meta.internal.flags.Flags, privatePrototype: scala.meta.Term.If, privateParent: scala.meta.Tree, privateOrigin: scala.meta.internal.ast.Origin, privateEnv: scala.meta.internal.semantic.Environment, privateTyping: scala.meta.internal.semantic.Typing)(_cond: scala.meta.Term, _thenp: scala.meta.Term, _elsep: scala.meta.Term): scala.meta.Term.If.TermIfImpl = {
      TermIfImpl.super.<init>();
      ()
    };
    def cond: scala.meta.Term = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.cond");
          this._cond_=({
            val copyCond$macro$301: scala.meta.Term = {
<artifact> val qual$97: scala.meta.Term = this.privatePrototype.cond;
<artifact> val x$1270: scala.meta.Term = this.privatePrototype.cond;
<artifact> val x$1271: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$1272: meta.internal.flags.Flags = qual$97.privateCopy$default$1;
<artifact> val x$1273: scala.meta.internal.ast.Origin = qual$97.privateCopy$default$4;
<artifact> val x$1274: scala.meta.internal.semantic.Environment = qual$97.privateCopy$default$5;
<artifact> val x$1275: scala.meta.internal.semantic.Denotation = qual$97.privateCopy$default$6;
<artifact> val x$1276: scala.meta.internal.semantic.Typing = qual$97.privateCopy$default$7;
qual$97.privateCopy(x$1272, x$1270, x$1271, x$1273, x$1274, x$1275, x$1276)
}.asInstanceOf[scala.meta.Term];
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term](copyCond$macro$301).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked)
            else
              copyCond$macro$301
          })
        }
      else
        (): Unit);
      this._cond
    };
    def thenp: scala.meta.Term = {
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.thenp");
          this._thenp_=({
            val copyThenp$macro$302: scala.meta.Term = {
<artifact> val qual$98: scala.meta.Term = this.privatePrototype.thenp;
<artifact> val x$1277: scala.meta.Term = this.privatePrototype.thenp;
<artifact> val x$1278: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$1279: meta.internal.flags.Flags = qual$98.privateCopy$default$1;
<artifact> val x$1280: scala.meta.internal.ast.Origin = qual$98.privateCopy$default$4;
<artifact> val x$1281: scala.meta.internal.semantic.Environment = qual$98.privateCopy$default$5;
<artifact> val x$1282: scala.meta.internal.semantic.Denotation = qual$98.privateCopy$default$6;
<artifact> val x$1283: scala.meta.internal.semantic.Typing = qual$98.privateCopy$default$7;
qual$98.privateCopy(x$1279, x$1277, x$1278, x$1280, x$1281, x$1282, x$1283)
}.asInstanceOf[scala.meta.Term];
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term](copyThenp$macro$302).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked)
            else
              copyThenp$macro$302
          })
        }
      else
        (): Unit);
      this._thenp
    };
    def elsep: scala.meta.Term = {
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.elsep");
          this._elsep_=({
            val copyElsep$macro$303: scala.meta.Term = {
<artifact> val qual$99: scala.meta.Term = this.privatePrototype.elsep;
<artifact> val x$1284: scala.meta.Term = this.privatePrototype.elsep;
<artifact> val x$1285: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$1286: meta.internal.flags.Flags = qual$99.privateCopy$default$1;
<artifact> val x$1287: scala.meta.internal.ast.Origin = qual$99.privateCopy$default$4;
<artifact> val x$1288: scala.meta.internal.semantic.Environment = qual$99.privateCopy$default$5;
<artifact> val x$1289: scala.meta.internal.semantic.Denotation = qual$99.privateCopy$default$6;
<artifact> val x$1290: scala.meta.internal.semantic.Typing = qual$99.privateCopy$default$7;
qual$99.privateCopy(x$1286, x$1284, x$1285, x$1287, x$1288, x$1289, x$1290)
}.asInstanceOf[scala.meta.Term];
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term](copyElsep$macro$303).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked)
            else
              copyElsep$macro$303
          })
        }
      else
        (): Unit);
      this._elsep
    };
    private[meta] def privateCopy(flags: meta.internal.flags.Flags = TermIfImpl.this.privateFlags, prototype: scala.meta.Tree = this, parent: scala.meta.Tree = TermIfImpl.this.privateParent, origin: scala.meta.internal.ast.Origin = TermIfImpl.this.privateOrigin, env: scala.meta.internal.semantic.Environment = TermIfImpl.this.privateEnv, denot: scala.meta.internal.semantic.Denotation = TermIfImpl.this.privateDenot, typing: scala.meta.internal.semantic.Typing = TermIfImpl.this.privateTyping): scala.meta.Tree = new If.this.TermIfImpl(flags, prototype.asInstanceOf[scala.meta.Term.If], parent, origin, env, typing)((null: scala.meta.Term), (null: scala.meta.Term), (null: scala.meta.Term));
    override <synthetic> def privateCopy$default$1: meta.internal.flags.Flags = TermIfImpl.this.privateFlags;
    override <synthetic> def privateCopy$default$2: scala.meta.Tree = this;
    override <synthetic> def privateCopy$default$3: scala.meta.Tree = TermIfImpl.this.privateParent;
    override <synthetic> def privateCopy$default$4: scala.meta.internal.ast.Origin = TermIfImpl.this.privateOrigin;
    override <synthetic> def privateCopy$default$5: scala.meta.internal.semantic.Environment = TermIfImpl.this.privateEnv;
    override <synthetic> def privateCopy$default$6: scala.meta.internal.semantic.Denotation = TermIfImpl.this.privateDenot;
    override <synthetic> def privateCopy$default$7: scala.meta.internal.semantic.Typing = TermIfImpl.this.privateTyping;
    def copy(cond: scala.meta.Term = this.cond, thenp: scala.meta.Term = this.thenp, elsep: scala.meta.Term = this.elsep): scala.meta.Term.If = Term.this.If.apply(cond, thenp, elsep);
    override <synthetic> def copy$default$1: scala.meta.Term = this.cond;
    override <synthetic> def copy$default$2: scala.meta.Term = this.thenp;
    override <synthetic> def copy$default$3: scala.meta.Term = this.elsep;
    def children: scala.collection.immutable.Seq[scala.meta.Tree] = (scala.collection.immutable.List.apply[scala.meta.Term](this.cond, this.thenp, this.elsep): scala.collection.immutable.Seq[scala.meta.Tree]);
    override def productPrefix: String = ("Term.If": String);
    override def productArity: Int = 3;
    override def productElement(n: Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
    };
    override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this);
    protected def writeReplace(): AnyRef = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.cond");
          this._cond_=({
            val copyCond$macro$304: scala.meta.Term = {
<artifact> val qual$100: scala.meta.Term = this.privatePrototype.cond;
<artifact> val x$1291: scala.meta.Term = this.privatePrototype.cond;
<artifact> val x$1292: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$1293: meta.internal.flags.Flags = qual$100.privateCopy$default$1;
<artifact> val x$1294: scala.meta.internal.ast.Origin = qual$100.privateCopy$default$4;
<artifact> val x$1295: scala.meta.internal.semantic.Environment = qual$100.privateCopy$default$5;
<artifact> val x$1296: scala.meta.internal.semantic.Denotation = qual$100.privateCopy$default$6;
<artifact> val x$1297: scala.meta.internal.semantic.Typing = qual$100.privateCopy$default$7;
qual$100.privateCopy(x$1293, x$1291, x$1292, x$1294, x$1295, x$1296, x$1297)
}.asInstanceOf[scala.meta.Term];
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term](copyCond$macro$304).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked)
            else
              copyCond$macro$304
          })
        }
      else
        (): Unit);
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.thenp");
          this._thenp_=({
            val copyThenp$macro$305: scala.meta.Term = {
<artifact> val qual$101: scala.meta.Term = this.privatePrototype.thenp;
<artifact> val x$1298: scala.meta.Term = this.privatePrototype.thenp;
<artifact> val x$1299: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$1300: meta.internal.flags.Flags = qual$101.privateCopy$default$1;
<artifact> val x$1301: scala.meta.internal.ast.Origin = qual$101.privateCopy$default$4;
<artifact> val x$1302: scala.meta.internal.semantic.Environment = qual$101.privateCopy$default$5;
<artifact> val x$1303: scala.meta.internal.semantic.Denotation = qual$101.privateCopy$default$6;
<artifact> val x$1304: scala.meta.internal.semantic.Typing = qual$101.privateCopy$default$7;
qual$101.privateCopy(x$1300, x$1298, x$1299, x$1301, x$1302, x$1303, x$1304)
}.asInstanceOf[scala.meta.Term];
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term](copyThenp$macro$305).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked)
            else
              copyThenp$macro$305
          })
        }
      else
        (): Unit);
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.elsep");
          this._elsep_=({
            val copyElsep$macro$306: scala.meta.Term = {
<artifact> val qual$102: scala.meta.Term = this.privatePrototype.elsep;
<artifact> val x$1305: scala.meta.Term = this.privatePrototype.elsep;
<artifact> val x$1306: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$1307: meta.internal.flags.Flags = qual$102.privateCopy$default$1;
<artifact> val x$1308: scala.meta.internal.ast.Origin = qual$102.privateCopy$default$4;
<artifact> val x$1309: scala.meta.internal.semantic.Environment = qual$102.privateCopy$default$5;
<artifact> val x$1310: scala.meta.internal.semantic.Denotation = qual$102.privateCopy$default$6;
<artifact> val x$1311: scala.meta.internal.semantic.Typing = qual$102.privateCopy$default$7;
qual$102.privateCopy(x$1307, x$1305, x$1306, x$1308, x$1309, x$1310, x$1311)
}.asInstanceOf[scala.meta.Term];
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term](copyElsep$macro$306).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.TermIfImpl](this).isTypechecked)
            else
              copyElsep$macro$306
          })
        }
      else
        (): Unit);
      this
    }
  };
  <synthetic> private def readResolve(): Object = Term.this.If
};
```
