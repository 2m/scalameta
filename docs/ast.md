We use macro annotations to generate swaths of boilerplate that are required for our abstract syntax trees
to be efficient and convenient. Here's the code that we write in [Trees.scala](/reflection/core/Trees.scala):

```
@ast class This(qual: Option[core.Name]) extends Ref with Mod.AccessQualifier
```

Here's the code generated by the `@ast` macro annotation:

```
@_root_.org.scalareflect.adt.Internal.leaf final class This private (
  // part 1: payload (qual) along with several bookkeeping fields
  private var internalQual: Option[core.Name],
  private val prototype: This,
  private val internalParent: Tree,
  private val scratchpads: _root_.scala.collection.immutable.Map[_root_.scala.reflect.semantic.HostContext, Any],
  val origin: _root_.scala.reflect.core.Origin
) extends Ref with Mod.AccessQualifier with _root_.scala.Product {
  // part 2: getters and setters for the payload
  import scala.language.experimental.macros;
  def qual: Option[core.Name] = {
    _root_.org.scalareflect.annotations.internal.ast.loadField(this.internalQual);
    this.internalQual
  };
  def qual_=(x: Tree): Unit = macro _root_.org.scalareflect.annotations.internal.ast.AstHelperMacros.payloadIsImmutable;
  def withQual(qual: Option[core.Name])(implicit origin: _root_.scala.reflect.core.Origin): ThisType = this.copy(qual = qual);
  def mapQual(f: _root_.scala.Function1[Option[core.Name], Option[core.Name]])(implicit origin: _root_.scala.reflect.core.Origin): ThisType = this.copy(qual = f(this.qual));
  def copy(qual: Option[core.Name] = this.qual)(implicit origin: _root_.scala.reflect.core.Origin): ThisType = This.apply(qual)(_root_.scala.reflect.core.Origin.Transform(this, this.origin));

  // part 3: getters and setters for bookkeeping fields
  def parent: Option[Tree] = if (internalParent.!=(null))
    _root_.scala.Some(internalParent)
  else
    _root_.scala.None;
  private[reflect] def internalWithParent(internalParent: Tree): ThisType = new ThisType(_root_.org.scalareflect.annotations.internal.ast.initField(this.internalQual), this, internalParent, scratchpads, origin);
  private[reflect] def scratchpad(implicit h: _root_.scala.reflect.semantic.HostContext): _root_.scala.Option[Any] = scratchpads.get(h);
  private[reflect] def withScratchpad(scratchpad: Any)(implicit h: _root_.scala.reflect.semantic.HostContext): ThisType = new ThisType(_root_.org.scalareflect.annotations.internal.ast.initField(this.internalQual), this, internalParent, scratchpads.+(h.->(scratchpad)), origin);
  private[reflect] def mapScratchpad(f: _root_.scala.Function1[_root_.scala.Option[Any], Any])(implicit h: _root_.scala.reflect.semantic.HostContext): ThisType = new ThisType(_root_.org.scalareflect.annotations.internal.ast.initField(this.internalQual), this, internalParent, scratchpads.+(h.->(f(scratchpads.get(h)))), origin);
  def withOrigin(origin: Origin): ThisType = new ThisType(_root_.org.scalareflect.annotations.internal.ast.initField(this.internalQual), this, internalParent, scratchpads, origin);
  def mapOrigin(f: _root_.scala.Function1[Origin, Origin]): ThisType = new ThisType(_root_.org.scalareflect.annotations.internal.ast.initField(this.internalQual), this, internalParent, scratchpads, f(origin));

  // part 4: advanced caseclass-like functionality
  override type ThisType = This;
  private[reflect] def tag: _root_.scala.Int = _root_.org.scalareflect.adt.Internal.calculateTag[ThisType];

  // part 5: standard caseclass-like functionality
  override def productPrefix: _root_.scala.Predef.String = _root_.org.scalareflect.annotations.internal.ast.productPrefix[ThisType];
  override def productArity: _root_.scala.Int = 1;
  override def productElement(n: _root_.scala.Int): Any = n match {
    case 0 => this.qual
    case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
  };
  override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this);
  override def canEqual(that: _root_.scala.Any): _root_.scala.Boolean = that.isInstanceOf[ThisType];
  override def equals(that: _root_.scala.Any): _root_.scala.Boolean = this.eq(that.asInstanceOf[AnyRef]);
  override def hashCode: _root_.scala.Int = _root_.java.lang.System.identityHashCode(this)
}
@_root_.org.scalareflect.adt.Internal.leaf object This {
  def apply(qual: Option[core.Name])(implicit origin: _root_.scala.reflect.core.Origin): This = {
    _root_.org.scalareflect.adt.Internal.hierarchyCheck[This];
    _root_.org.scalareflect.adt.Internal.nullCheck(qual);
    _root_.org.scalareflect.adt.Internal.emptyCheck(qual);
    val node = new This(_root_.org.scalareflect.annotations.internal.ast.initParam(qual), prototype = null, internalParent = null, scratchpads = _root_.scala.collection.immutable.Map(), origin = origin);
    _root_.org.scalareflect.annotations.internal.ast.storeField(node.internalQual, qual);
    node
  };
  def unapply(x: This): Option[Option[core.Name]] = if (x.==(null))
    _root_.scala.None
  else
    _root_.scala.Some(x.qual)
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@org.scalareflect.adt.Internal.leaf final class This extends AnyRef with scala.reflect.core.Term.Ref with scala.reflect.core.Mod.AccessQualifier with Product {
  <paramaccessor> private[this] var internalQual: Option[scala.reflect.core.Name] = _;
  <accessor> <paramaccessor> private def internalQual: Option[scala.reflect.core.Name] = This.this.internalQual;
  <accessor> <paramaccessor> private def internalQual_=(x$1: Option[scala.reflect.core.Name]): Unit = This.this.internalQual = x$1;
  <paramaccessor> private[this] val prototype: scala.reflect.core.Term.This = _;
  <stable> <accessor> <paramaccessor> private def prototype: scala.reflect.core.Term.This = This.this.prototype;
  <paramaccessor> private[this] val internalParent: scala.reflect.core.Tree = _;
  <stable> <accessor> <paramaccessor> private def internalParent: scala.reflect.core.Tree = This.this.internalParent;
  <paramaccessor> private[this] val scratchpads: scala.collection.immutable.Map[scala.reflect.semantic.HostContext,Any] = _;
  <stable> <accessor> <paramaccessor> private def scratchpads: scala.collection.immutable.Map[scala.reflect.semantic.HostContext,Any] = This.this.scratchpads;
  <paramaccessor> private[this] val origin: reflect.core.Origin = _;
  <stable> <accessor> <paramaccessor> def origin: reflect.core.Origin = This.this.origin;
  private def <init>(internalQual: Option[scala.reflect.core.Name], prototype: scala.reflect.core.Term.This, internalParent: scala.reflect.core.Tree, scratchpads: scala.collection.immutable.Map[scala.reflect.semantic.HostContext,Any], origin: reflect.core.Origin): scala.reflect.core.Term.This = {
    This.super.<init>();
    ()
  };
  import scala.language.experimental.macros;
  def qual: Option[scala.reflect.core.Name] = {
    (if (this.internalQual.==(null))
      {
        scala.Predef.require(this.prototype.!=(null));
        this.internalQual_=(this.prototype.qual.map[scala.reflect.core.Name#ThisType](((x$11: scala.reflect.core.Name) => x$11.internalWithParent(this))))
      }
    else
      (): Unit);
    this.internalQual
  };
  @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalareflect.annotations.package$internal$ast$AstHelperMacros", "methodName" = "payloadIsImmutable", "signature" = List(List(-3)))) <macro> def qual_=(x: scala.reflect.core.Tree): Unit = new org.scalareflect.annotations.`package`.internal.ast.AstHelperMacros(???).payloadIsImmutable;
  def withQual(qual: Option[scala.reflect.core.Name])(implicit origin: reflect.core.Origin): This.this.ThisType = this.copy(qual)(origin);
  def mapQual(f: Option[scala.reflect.core.Name] => Option[scala.reflect.core.Name])(implicit origin: reflect.core.Origin): This.this.ThisType = this.copy(f.apply(this.qual))(origin);
  def copy(qual: Option[scala.reflect.core.Name] = this.qual)(implicit origin: reflect.core.Origin): This.this.ThisType = Term.this.This.apply(qual)(scala.reflect.core.`package`.Origin.Transform.apply(this, this.origin));
  <synthetic> def copy$default$1: Option[scala.reflect.core.Name] = this.qual;
  def parent: Option[scala.reflect.core.Tree] = if (This.this.internalParent.!=(null))
    scala.Some.apply[scala.reflect.core.Tree](This.this.internalParent)
  else
    scala.None;
  private[reflect] def internalWithParent(internalParent: scala.reflect.core.Tree): This.this.ThisType = new This.this.ThisType((null: Option[scala.reflect.core.Name]), this, internalParent, This.this.scratchpads, This.this.origin);
  private[reflect] def scratchpad(implicit h: scala.reflect.semantic.HostContext): Option[Any] = This.this.scratchpads.get(h);
  private[reflect] def withScratchpad(scratchpad: Any)(implicit h: scala.reflect.semantic.HostContext): This.this.ThisType = new This.this.ThisType((null: Option[scala.reflect.core.Name]), this, This.this.internalParent, This.this.scratchpads.+[Any](scala.this.Predef.ArrowAssoc[scala.reflect.semantic.HostContext](h).->[Any](scratchpad)), This.this.origin);
  private[reflect] def mapScratchpad(f: Option[Any] => Any)(implicit h: scala.reflect.semantic.HostContext): This.this.ThisType = new This.this.ThisType((null: Option[scala.reflect.core.Name]), this, This.this.internalParent, This.this.scratchpads.+[Any](scala.this.Predef.ArrowAssoc[scala.reflect.semantic.HostContext](h).->[Any](f.apply(This.this.scratchpads.get(h)))), This.this.origin);
  def withOrigin(origin: scala.reflect.core.Origin): This.this.ThisType = new This.this.ThisType((null: Option[scala.reflect.core.Name]), this, This.this.internalParent, This.this.scratchpads, origin);
  def mapOrigin(f: scala.reflect.core.Origin => scala.reflect.core.Origin): This.this.ThisType = new This.this.ThisType((null: Option[scala.reflect.core.Name]), this, This.this.internalParent, This.this.scratchpads, f.apply(This.this.origin));
  override type ThisType = scala.reflect.core.Term.This;
  private[reflect] def tag: Int = 1;
  override def productPrefix: String = ("Term.This": String);
  override def productArity: Int = 1;
  override def productElement(n: Int): Any = n match {
    case 0 => this.qual
    case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
  };
  override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this);
  override def canEqual(that: Any): Boolean = that.isInstanceOf[This.this.ThisType];
  override def equals(that: Any): Boolean = this.eq(that.asInstanceOf[AnyRef]);
  override def hashCode: Int = java.lang.System.identityHashCode(this)
};
@@<?> object This extends scala.AnyRef {
  def <init>(): scala.reflect.core.Term.This.type = {
    This.super.<init>();
    ()
  };
  def apply(qual: Option[scala.reflect.core.Name])(implicit origin: reflect.core.Origin): scala.reflect.core.Term.This = {
    <empty>;
    ({
      val result$macro$4: Boolean = qual.!=(null);
      if (result$macro$4)
        scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
      else
        scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("qual is equal to null"))
    } match {
      case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
      case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$3 @ _)) => {
        org.scalareflect.invariants.InvariantFailedException.raise("qual.!=(null)", failures$macro$3, scala.Some.apply[scala.reflect.core.Term.This.type](This.this));
        ()
      }
    }: Unit);
    <empty>;
    val node: scala.reflect.core.Term.This = new Term.this.This((null: Option[scala.reflect.core.Name]), null, null, scala.collection.immutable.Map.apply[scala.reflect.semantic.HostContext, Nothing](), origin);
    (node.internalQual_=(qual.map[scala.reflect.core.Name#ThisType](((x$12: scala.reflect.core.Name) => x$12.internalWithParent(node)))): Unit);
    node
  };
  def unapply(x: scala.reflect.core.Term.This): Option[Option[scala.reflect.core.Name]] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[Option[scala.reflect.core.Name]](x.qual)
};
```