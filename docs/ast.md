We use macro annotations to generate swaths of boilerplate that are required for our abstract syntax trees
to be efficient and convenient. Here's the code that we write in [Trees.scala](/reflection/core/Trees.scala):

```
object Type {
  ...
  @ast class Name(value: String @nonEmpty)(isBackquoted: Boolean) extends core.Name with Ref {
    require(keywords.contains(value) ==> isBackquoted)
  }
  ...
}
```

Here's the code generated by the `@ast` macro annotation:

```
@_root_.org.scalareflect.adt.Internal.leaf final class Name private (
  // part 1: several bookkeeping fields
  private val prototype: Name,
  private val internalParent: Tree,
  private val scratchpads: _root_.scala.collection.immutable.Map[_root_.scala.reflect.semantic.HostContext, Any],
  val origin: _root_.scala.reflect.core.Origin
)(
  // part 2a: first parameter list of the payload
  private var _value: String @nonEmpty
)(
  // part 2b: first parameter list of the payload
  private var _isBackquoted: Boolean
) extends core.Name with Ref with _root_.scala.Product {
  // part 4: getters and "setters" for bookkeeping fields
  def parent: Option[Tree] = if (internalParent.!=(null))
    _root_.scala.Some(internalParent)
  else
    _root_.scala.None;
  private[core] def internalWithParent(internalParent: Tree): ThisType = new ThisType(this, internalParent, scratchpads, origin)(_root_.org.scalareflect.annotations.internal.ast.initField(this._value))(_root_.org.scalareflect.annotations.internal.ast.initField(this._isBackquoted));
  private[reflect] def scratchpad(implicit h: _root_.scala.reflect.semantic.HostContext): _root_.scala.Option[Any] = scratchpads.get(h);
  private[reflect] def withScratchpad(scratchpad: Any)(implicit h: _root_.scala.reflect.semantic.HostContext): ThisType = new ThisType(this, internalParent, scratchpads.+(h.->(scratchpad)), origin)(_root_.org.scalareflect.annotations.internal.ast.initField(this._value))(_root_.org.scalareflect.annotations.internal.ast.initField(this._isBackquoted));
  private[reflect] def mapScratchpad(f: _root_.scala.Function1[_root_.scala.Option[Any], Any])(implicit h: _root_.scala.reflect.semantic.HostContext): ThisType = new ThisType(this, internalParent, scratchpads.+(h.->(f(scratchpads.get(h)))), origin)(_root_.org.scalareflect.annotations.internal.ast.initField(this._value))(_root_.org.scalareflect.annotations.internal.ast.initField(this._isBackquoted));
  def withOrigin(origin: Origin): ThisType = new ThisType(this, internalParent, scratchpads, origin)(_root_.org.scalareflect.annotations.internal.ast.initField(this._value))(_root_.org.scalareflect.annotations.internal.ast.initField(this._isBackquoted));
  def mapOrigin(f: _root_.scala.Function1[Origin, Origin]): ThisType = new ThisType(this, internalParent, scratchpads, f(origin))(_root_.org.scalareflect.annotations.internal.ast.initField(this._value))(_root_.org.scalareflect.annotations.internal.ast.initField(this._isBackquoted));

  // part 5: getters and "setters" for the payload
  import scala.language.experimental.macros;
  def value: String @nonEmpty = {
    _root_.org.scalareflect.annotations.internal.ast.loadField(this._value);
    this._value
  };
  def withValue(value: String @nonEmpty)(implicit origin: _root_.scala.reflect.core.Origin): ThisType = this.copy(value = this.value)(this.isBackquoted);
  def mapValue(f: _root_.scala.Function1[String @nonEmpty, String @nonEmpty])(implicit origin: _root_.scala.reflect.core.Origin): ThisType = this.copy(value = f(this.value))(this.isBackquoted);
  def isBackquoted: Boolean = {
    _root_.org.scalareflect.annotations.internal.ast.loadField(this._isBackquoted);
    this._isBackquoted
  };
  def withIsBackquoted(isBackquoted: Boolean)(implicit origin: _root_.scala.reflect.core.Origin): ThisType = this.copy(this.value)(isBackquoted = this.isBackquoted);
  def mapIsBackquoted(f: _root_.scala.Function1[Boolean, Boolean])(implicit origin: _root_.scala.reflect.core.Origin): ThisType = this.copy(this.value)(isBackquoted = f(this.isBackquoted));
  def copy(value: String @nonEmpty = this.value)(isBackquoted: Boolean = this.isBackquoted)(implicit origin: _root_.scala.reflect.core.Origin): ThisType = Name.apply(value)(isBackquoted)(_root_.scala.reflect.core.Origin.Transform(this, this.origin));

  // part 6: advanced caseclass-like functionality
  override type ThisType = Name;
  def $tag: _root_.scala.Int = _root_.org.scalareflect.adt.Internal.calculateTag[ThisType];

  // part 7: standard caseclass-like functionality
  override def productPrefix: _root_.scala.Predef.String = _root_.org.scalareflect.annotations.internal.ast.productPrefix[ThisType];
  override def productArity: _root_.scala.Int = 1;
  override def productElement(n: _root_.scala.Int): Any = n match {
    case 0 => this.value
    case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
  };
  override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this);
  override def canEqual(that: _root_.scala.Any): _root_.scala.Boolean = that.isInstanceOf[ThisType];
  override def equals(that: _root_.scala.Any): _root_.scala.Boolean = this.eq(that.asInstanceOf[AnyRef]);
  override def hashCode: _root_.scala.Int = _root_.java.lang.System.identityHashCode(this)
}
@_root_.org.scalareflect.adt.Internal.leaf object Name {
  def apply(value: String @nonEmpty)(isBackquoted: Boolean)(implicit origin: _root_.scala.reflect.core.Origin): Name = {
    _root_.org.scalareflect.adt.Internal.hierarchyCheck[Name];
    _root_.org.scalareflect.adt.Internal.nullCheck(value);
    _root_.org.scalareflect.adt.Internal.nullCheck(isBackquoted);
    _root_.org.scalareflect.adt.Internal.emptyCheck(value);
    _root_.org.scalareflect.adt.Internal.emptyCheck(isBackquoted);
    require(keywords.contains(value).==>(isBackquoted));
    val node = new Name(prototype = null, internalParent = null, scratchpads = _root_.scala.collection.immutable.Map(), origin = origin)(_root_.org.scalareflect.annotations.internal.ast.initParam(value))(_root_.org.scalareflect.annotations.internal.ast.initParam(isBackquoted));
    _root_.org.scalareflect.annotations.internal.ast.storeField(node._value, value);
    _root_.org.scalareflect.annotations.internal.ast.storeField(node._isBackquoted, isBackquoted);
    node
  };
  def unapply(x: Name): Option[String @nonEmpty] = if (x.==(null))
    _root_.scala.None
  else
    _root_.scala.Some(x.value)
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@org.scalareflect.adt.Internal.leaf final class Name extends AnyRef with scala.reflect.core.Name with scala.reflect.core.Type.Ref with Product {
  <paramaccessor> private[this] val prototype: scala.reflect.core.Type.Name = _;
  <stable> <accessor> <paramaccessor> private def prototype: scala.reflect.core.Type.Name = Name.this.prototype;
  <paramaccessor> private[this] val internalParent: scala.reflect.core.Tree = _;
  <stable> <accessor> <paramaccessor> private def internalParent: scala.reflect.core.Tree = Name.this.internalParent;
  <paramaccessor> private[this] val scratchpads: scala.collection.immutable.Map[scala.reflect.semantic.HostContext,Any] = _;
  <stable> <accessor> <paramaccessor> private def scratchpads: scala.collection.immutable.Map[scala.reflect.semantic.HostContext,Any] = Name.this.scratchpads;
  <paramaccessor> private[this] val origin: reflect.core.Origin = _;
  <stable> <accessor> <paramaccessor> def origin: reflect.core.Origin = Name.this.origin;
  <paramaccessor> private[this] var _value: String @org.scalareflect.invariants.nonEmpty = _;
  <accessor> <paramaccessor> private def _value: String = Name.this._value;
  <accessor> <paramaccessor> private def _value_=(x$1: String @org.scalareflect.invariants.nonEmpty): Unit = Name.this._value = x$1;
  <paramaccessor> private[this] var _isBackquoted: Boolean = _;
  <accessor> <paramaccessor> private def _isBackquoted: Boolean = Name.this._isBackquoted;
  <accessor> <paramaccessor> private def _isBackquoted_=(x$1: Boolean): Unit = Name.this._isBackquoted = x$1;
  private def <init>(prototype: scala.reflect.core.Type.Name, internalParent: scala.reflect.core.Tree, scratchpads: scala.collection.immutable.Map[scala.reflect.semantic.HostContext,Any], origin: reflect.core.Origin)(_value: String @org.scalareflect.invariants.nonEmpty)(_isBackquoted: Boolean): scala.reflect.core.Type.Name = {
    Name.super.<init>();
    ()
  };
  def parent: Option[scala.reflect.core.Tree] = if (Name.this.internalParent.!=(null))
    scala.Some.apply[scala.reflect.core.Tree](Name.this.internalParent)
  else
    scala.None;
  private[core] def internalWithParent(internalParent: scala.reflect.core.Tree): Name.this.ThisType = new Name.this.ThisType(this, internalParent, Name.this.scratchpads, Name.this.origin)((this._value: String))((this._isBackquoted: Boolean));
  private[reflect] def scratchpad(implicit h: scala.reflect.semantic.HostContext): Option[Any] = Name.this.scratchpads.get(h);
  private[reflect] def withScratchpad(scratchpad: Any)(implicit h: scala.reflect.semantic.HostContext): Name.this.ThisType = new Name.this.ThisType(this, Name.this.internalParent, Name.this.scratchpads.+[Any](scala.this.Predef.ArrowAssoc[scala.reflect.semantic.HostContext](h).->[Any](scratchpad)), Name.this.origin)((this._value: String))((this._isBackquoted: Boolean));
  private[reflect] def mapScratchpad(f: Option[Any] => Any)(implicit h: scala.reflect.semantic.HostContext): Name.this.ThisType = new Name.this.ThisType(this, Name.this.internalParent, Name.this.scratchpads.+[Any](scala.this.Predef.ArrowAssoc[scala.reflect.semantic.HostContext](h).->[Any](f.apply(Name.this.scratchpads.get(h)))), Name.this.origin)((this._value: String))((this._isBackquoted: Boolean));
  def withOrigin(origin: scala.reflect.core.Origin): Name.this.ThisType = new Name.this.ThisType(this, Name.this.internalParent, Name.this.scratchpads, origin)((this._value: String))((this._isBackquoted: Boolean));
  def mapOrigin(f: scala.reflect.core.Origin => scala.reflect.core.Origin): Name.this.ThisType = new Name.this.ThisType(this, Name.this.internalParent, Name.this.scratchpads, f.apply(Name.this.origin))((this._value: String))((this._isBackquoted: Boolean));
  import scala.language.experimental.macros;
  def value: String = {
    (<empty>: Unit);
    this._value
  };
  def withValue(value: String @org.scalareflect.invariants.nonEmpty)(implicit origin: reflect.core.Origin): Name.this.ThisType = this.copy(this.value)(this.isBackquoted)(origin);
  def mapValue(f: String @org.scalareflect.invariants.nonEmpty => String @org.scalareflect.invariants.nonEmpty)(implicit origin: reflect.core.Origin): Name.this.ThisType = this.copy(f.apply(this.value))(this.isBackquoted)(origin);
  def isBackquoted: Boolean = {
    (<empty>: Unit);
    this._isBackquoted
  };
  def withIsBackquoted(isBackquoted: Boolean)(implicit origin: reflect.core.Origin): Name.this.ThisType = this.copy(this.value)(this.isBackquoted)(origin);
  def mapIsBackquoted(f: Boolean => Boolean)(implicit origin: reflect.core.Origin): Name.this.ThisType = this.copy(this.value)(f.apply(this.isBackquoted))(origin);
  def copy(value: String @org.scalareflect.invariants.nonEmpty = this.value)(isBackquoted: Boolean = this.isBackquoted)(implicit origin: reflect.core.Origin): Name.this.ThisType = Type.this.Name.apply(value)(isBackquoted)(scala.reflect.core.`package`.Origin.Transform.apply(this, this.origin));
  <synthetic> def copy$default$1: String = this.value;
  <synthetic> def copy$default$2(value: String @org.scalareflect.invariants.nonEmpty): Boolean = this.isBackquoted;
  override type ThisType = scala.reflect.core.Type.Name;
  override def $tag: Int = 31;
  override def productPrefix: String = ("Type.Name": String);
  override def productArity: Int = 1;
  override def productElement(n: Int): Any = n match {
    case 0 => this.value
    case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
  };
  override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this);
  override def canEqual(that: Any): Boolean = that.isInstanceOf[Name.this.ThisType];
  override def equals(that: Any): Boolean = this.eq(that.asInstanceOf[AnyRef]);
  override def hashCode: Int = java.lang.System.identityHashCode(this)
};
@@<?> object Name extends scala.AnyRef {
  def <init>(): scala.reflect.core.Type.Name.type = {
    Name.super.<init>();
    ()
  };
  def apply(value: String @org.scalareflect.invariants.nonEmpty)(isBackquoted: Boolean)(implicit origin: reflect.core.Origin): scala.reflect.core.Type.Name = {
    <empty>;
    ({
      val result$macro$332: Boolean = value.!=(null);
      if (result$macro$332)
        scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
      else
        scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("value is equal to null"))
    } match {
      case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
      case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$331 @ _)) => {
        org.scalareflect.invariants.InvariantFailedException.raise("value.!=(null)", failures$macro$331, scala.Some.apply[scala.reflect.core.Type.Name.type](Name.this));
        ()
      }
    }: Unit);
    <empty>;
    ({
      val result$macro$334: Boolean = scala.this.Predef.augmentString(value).nonEmpty;
      if (result$macro$334)
        scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
      else
        scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("scala.Predef.augmentString(value).nonEmpty is false"))
    } match {
      case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
      case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$333 @ _)) => {
        org.scalareflect.invariants.InvariantFailedException.raise("scala.Predef.augmentString(value).nonEmpty", failures$macro$333, scala.Some.apply[scala.reflect.core.Type.Name.type](Name.this));
        ()
      }
    }: Unit);
    <empty>;
    ({
      val result$macro$336: Boolean = org.scalareflect.invariants.`package`.Implication(scala.reflect.syntactic.`package`.keywords.contains(value)).==>(isBackquoted);
      if (result$macro$336)
        scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
      else
        scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("org.scalareflect.invariants.`package`.Implication(scala.reflect.syntactic.`package`.keywords.contains(value)).==>(isBackquoted) is false"))
    } match {
      case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
      case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$335 @ _)) => {
        org.scalareflect.invariants.InvariantFailedException.raise("org.scalareflect.invariants.`package`.Implication(scala.reflect.syntactic.`package`.keywords.contains(value)).==>(isBackquoted)", failures$macro$335, scala.Some.apply[scala.reflect.core.Type.Name.type](Name.this));
        ()
      }
    }: Unit);
    val node: scala.reflect.core.Type.Name = new Type.this.Name(null, null, scala.collection.immutable.Map.apply[scala.reflect.semantic.HostContext, Nothing](), origin)((value: String))((isBackquoted: Boolean));
    (<empty>: Unit);
    (<empty>: Unit);
    node
  };
  def unapply(x: scala.reflect.core.Type.Name): Option[String] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[String](x.value)
};
```
