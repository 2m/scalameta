### Internal structure of scala.meta ASTs

We use macro annotations to generate swaths of boilerplate that are required for our abstract syntax trees
to be efficient and convenient. Here's the code that we write in [Trees.scala](/scalameta/src/main/scala/scala/meta/Trees.scala):

```
@ast class If(cond: Term, thenp: Term, elsep: Term) extends Term
```

Here's the code generated by the `@ast` macro annotation:

```
@new _root_.org.scalameta.ast.internal.astClass() @new _root_.org.scalameta.adt.Internal.leafClass()
abstract trait If extends Term with _root_.scala.Product {
  @new _root_.org.scalameta.ast.internal.astField() def cond: Term;
  @new _root_.org.scalameta.ast.internal.astField() def thenp: Term;
  @new _root_.org.scalameta.ast.internal.astField() def elsep: Term;
  override type ThisType <: If
}
@new _root_.org.scalameta.ast.internal.astCompanion() @new _root_.org.scalameta.adt.Internal.leafCompanion()
object If extends scala.AnyRef {
  def internalTag: _root_.scala.Int = _root_.org.scalameta.adt.Internal.calculateTag[If];
  def apply(cond: Term, thenp: Term, elsep: Term, origin: _root_.scala.meta.Origin = _root_.scala.meta.Origin.None): If = {
    def internal(cond: Term, thenp: Term, elsep: Term, origin: _root_.scala.meta.Origin): If = {
      _root_.org.scalameta.ast.internal.hierarchyCheck[If];
      _root_.org.scalameta.adt.Internal.nullCheck(cond);
      _root_.org.scalameta.adt.Internal.nullCheck(thenp);
      _root_.org.scalameta.adt.Internal.nullCheck(elsep);
      _root_.org.scalameta.adt.Internal.emptyCheck(cond);
      _root_.org.scalameta.adt.Internal.emptyCheck(thenp);
      _root_.org.scalameta.adt.Internal.emptyCheck(elsep);
      val node = new Impl(null, null, _root_.scala.collection.immutable.Nil, origin)(_root_.org.scalameta.ast.internal.initParam(cond), _root_.org.scalameta.ast.internal.initParam(thenp), _root_.org.scalameta.ast.internal.initParam(elsep));
      _root_.org.scalameta.ast.internal.storeField(node._cond, cond);
      _root_.org.scalameta.ast.internal.storeField(node._thenp, thenp);
      _root_.org.scalameta.ast.internal.storeField(node._elsep, elsep);
      node
    };
    internal(cond, thenp, elsep, origin)
  };
  @new _root_.scala.inline() final def unapply(x: If): Option[scala.Tuple3[Term, Term, Term]] = if (x.$eq$eq(null))
    _root_.scala.None
  else
    _root_.scala.Some(scala.Tuple3(x.cond, x.thenp, x.elsep));
  import _root_.scala.language.experimental.{macros=>prettyPlease};
  import _root_.scala.language.implicitConversions;
  implicit <macro> def interfaceToApi(interface: If): Api = _root_.org.scalameta.ast.internal.Macros.interfaceToApi[If, Api];
  abstract trait Api extends If {
    def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep, origin: _root_.scala.meta.Origin = _root_.scala.meta.Origin.Transformed(this)): ThisType = If.apply(cond, thenp, elsep, origin);
    override type ThisType = If;
    override def internalTag: _root_.scala.Int = If.internalTag;
    override def productPrefix: _root_.scala.Predef.String = _root_.org.scalameta.ast.internal.productPrefix[ThisType];
    override def productArity: _root_.scala.Int = 3;
    override def productElement(n: _root_.scala.Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
    };
    override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this)
  };
  private[If] final class Impl (
    protected val internalPrototype: If,
    protected val internalParent: _root_.scala.meta.Tree,
    protected val internalScratchpad: _root_.scala.collection.immutable.Seq[Any],
    protected val internalOrigin: _root_.scala.meta.Origin
  )(
    var _cond: Term,
    var _thenp: Term,
    var _elsep: Term
  ) extends If {
    private[meta] def internalCopy(prototype: _root_.scala.meta.Tree = this, parent: _root_.scala.meta.Tree = internalParent, scratchpad: _root_.scala.collection.immutable.Seq[Any] = internalScratchpad, origin: _root_.scala.meta.Origin = internalOrigin): ThisType = new Impl(prototype.asInstanceOf[ThisType], parent, scratchpad, origin)(_root_.org.scalameta.ast.internal.initField(this._cond), _root_.org.scalameta.ast.internal.initField(this._thenp), _root_.org.scalameta.ast.internal.initField(this._elsep));
    def parent: _root_.scala.Option[_root_.scala.meta.Tree] = if (internalParent.$bang$eq(null))
      _root_.scala.Some(internalParent)
    else
      _root_.scala.None;
    def origin: _root_.scala.meta.Origin = internalOrigin;
    def cond: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._cond);
      this._cond
    };
    def thenp: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._thenp);
      this._thenp
    };
    def elsep: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._elsep);
      this._elsep
    }
  }
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass abstract trait If extends AnyRef with scala.meta.internal.ast.Term with Product {
  @org.scalameta.ast.internal.astField def cond: scala.meta.internal.ast.Term;
  @org.scalameta.ast.internal.astField def thenp: scala.meta.internal.ast.Term;
  @org.scalameta.ast.internal.astField def elsep: scala.meta.internal.ast.Term;
  override type ThisType <: scala.meta.internal.ast.Term.If
};
@@<?> @@<?> object If extends scala.AnyRef {
  def <init>(): scala.meta.internal.ast.Term.If.type = {
    If.super.<init>();
    ()
  };
  def internalTag: Int = 21;
  def apply(cond: scala.meta.internal.ast.Term, thenp: scala.meta.internal.ast.Term, elsep: scala.meta.internal.ast.Term, origin: scala.meta.Origin = scala.meta.Origin.None): scala.meta.internal.ast.Term.If = {
    def internal(cond: scala.meta.internal.ast.Term, thenp: scala.meta.internal.ast.Term, elsep: scala.meta.internal.ast.Term, origin: scala.meta.Origin): scala.meta.internal.ast.Term.If = {
      ((): Unit);
      ((): Unit);
      ({
        val result$macro$291: Boolean = cond.!=(null);
        if (result$macro$291)
          scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("cond is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$290 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("cond.!=(null)", failures$macro$290, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("cond", cond)))
      }: Unit);
      ({
        val result$macro$293: Boolean = thenp.!=(null);
        if (result$macro$293)
          scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("thenp is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$292 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("thenp.!=(null)", failures$macro$292, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("thenp", thenp)))
      }: Unit);
      ({
        val result$macro$295: Boolean = elsep.!=(null);
        if (result$macro$295)
          scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("elsep is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$294 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("elsep.!=(null)", failures$macro$294, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("elsep", elsep)))
      }: Unit);
      ();
      ();
      ();
      val node: scala.meta.internal.ast.Term.If.Impl = new If.this.Impl(null, null, scala.collection.immutable.Nil, origin)((null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term));
      (node._cond_=(cond.internalCopy(cond, node, cond.internalCopy$default$3, cond.internalCopy$default$4)): Unit);
      (node._thenp_=(thenp.internalCopy(thenp, node, thenp.internalCopy$default$3, thenp.internalCopy$default$4)): Unit);
      (node._elsep_=(elsep.internalCopy(elsep, node, elsep.internalCopy$default$3, elsep.internalCopy$default$4)): Unit);
      node
    };
    internal(cond, thenp, elsep, origin)
  };
  <synthetic> def apply$default$4: scala.meta.Origin = scala.meta.Origin.None;
  @inline final def unapply(x: scala.meta.internal.ast.Term.If): Option[(scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term)] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[(scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term)](scala.Tuple3.apply[scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term](x.cond, x.thenp, x.elsep));
  import scala.language.experimental.{macros=>prettyPlease};
  import scala.language.implicitConversions;
  @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalameta.ast.internal$Macros", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.internal.ast.Term.If, scala.meta.internal.ast.Term.If.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.internal.ast.Term.If): scala.meta.internal.ast.Term.If.Api = new org.scalameta.ast.internal.Macros(null).interfaceToApi[scala.meta.internal.ast.Term.If, scala.meta.internal.ast.Term.If.Api];
  abstract trait Api extends AnyRef with scala.meta.internal.ast.Term.If {
    def /*Api*/$init$(): Unit = {
      ()
    };
    def copy(cond: scala.meta.internal.ast.Term = this.cond, thenp: scala.meta.internal.ast.Term = this.thenp, elsep: scala.meta.internal.ast.Term = this.elsep, origin: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this)): Api.this.ThisType = Term.this.If.apply(cond, thenp, elsep, origin);
    <synthetic> def copy$default$1: scala.meta.internal.ast.Term = this.cond;
    <synthetic> def copy$default$2: scala.meta.internal.ast.Term = this.thenp;
    <synthetic> def copy$default$3: scala.meta.internal.ast.Term = this.elsep;
    <synthetic> def copy$default$4: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this);
    override type ThisType = scala.meta.internal.ast.Term.If;
    override def internalTag: Int = Term.this.If.internalTag;
    override def productPrefix: String = ("Term.If": String);
    override def productArity: Int = 3;
    override def productElement(n: Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
    };
    override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
  };
  final private[If] class Impl extends AnyRef with scala.meta.internal.ast.Term.If.Api {
    <paramaccessor> private[this] val internalPrototype: scala.meta.internal.ast.Term.If = _;
    <stable> <accessor> <paramaccessor> protected def internalPrototype: scala.meta.internal.ast.Term.If = Impl.this.internalPrototype;
    <paramaccessor> private[this] val internalParent: scala.meta.Tree = _;
    <stable> <accessor> <paramaccessor> protected def internalParent: scala.meta.Tree = Impl.this.internalParent;
    <paramaccessor> private[this] val internalScratchpad: scala.collection.immutable.Seq[Any] = _;
    <stable> <accessor> <paramaccessor> protected def internalScratchpad: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad;
    <paramaccessor> private[this] val internalOrigin: scala.meta.Origin = _;
    <stable> <accessor> <paramaccessor> protected def internalOrigin: scala.meta.Origin = Impl.this.internalOrigin;
    <paramaccessor> private[this] var _cond: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _cond: scala.meta.internal.ast.Term = Impl.this._cond;
    <accessor> <paramaccessor> def _cond_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._cond = x$1;
    <paramaccessor> private[this] var _thenp: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _thenp: scala.meta.internal.ast.Term = Impl.this._thenp;
    <accessor> <paramaccessor> def _thenp_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._thenp = x$1;
    <paramaccessor> private[this] var _elsep: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _elsep: scala.meta.internal.ast.Term = Impl.this._elsep;
    <accessor> <paramaccessor> def _elsep_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._elsep = x$1;
    def <init>(internalPrototype: scala.meta.internal.ast.Term.If, internalParent: scala.meta.Tree, internalScratchpad: scala.collection.immutable.Seq[Any], internalOrigin: scala.meta.Origin)(_cond: scala.meta.internal.ast.Term, _thenp: scala.meta.internal.ast.Term, _elsep: scala.meta.internal.ast.Term): scala.meta.internal.ast.Term.If.Impl = {
      Impl.super.<init>();
      ()
    };
    private[meta] def internalCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.internalParent, scratchpad: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad, origin: scala.meta.Origin = Impl.this.internalOrigin): Impl.this.ThisType = new If.this.Impl(prototype.asInstanceOf[Impl.this.ThisType], parent, scratchpad, origin)((null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term));
    override <synthetic> def internalCopy$default$1: scala.meta.Tree = this;
    override <synthetic> def internalCopy$default$2: scala.meta.Tree = Impl.this.internalParent;
    override <synthetic> def internalCopy$default$3: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad;
    override <synthetic> def internalCopy$default$4: scala.meta.Origin = Impl.this.internalOrigin;
    def parent: Option[scala.meta.Tree] = if (Impl.this.internalParent.!=(null))
      scala.Some.apply[scala.meta.Tree](Impl.this.internalParent)
    else
      scala.None;
    def origin: scala.meta.Origin = Impl.this.internalOrigin;
    def cond: scala.meta.internal.ast.Term = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.cond");
          this._cond_=({
            <artifact> val qual$19: scala.meta.internal.ast.Term = this.internalPrototype.cond;
            <artifact> val x$97: scala.meta.internal.ast.Term = this.internalPrototype.cond;
            <artifact> val x$98: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$99: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$19.internalCopy$default$3;
            <artifact> val x$100: scala.meta.Origin = qual$19.internalCopy$default$4;
            qual$19.internalCopy(x$97, x$98, x$99, x$100)
          })
        }
      else
        (): Unit);
      this._cond
    };
    def thenp: scala.meta.internal.ast.Term = {
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.thenp");
          this._thenp_=({
            <artifact> val qual$20: scala.meta.internal.ast.Term = this.internalPrototype.thenp;
            <artifact> val x$101: scala.meta.internal.ast.Term = this.internalPrototype.thenp;
            <artifact> val x$102: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$103: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$20.internalCopy$default$3;
            <artifact> val x$104: scala.meta.Origin = qual$20.internalCopy$default$4;
            qual$20.internalCopy(x$101, x$102, x$103, x$104)
          })
        }
      else
        (): Unit);
      this._thenp
    };
    def elsep: scala.meta.internal.ast.Term = {
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.elsep");
          this._elsep_=({
            <artifact> val qual$21: scala.meta.internal.ast.Term = this.internalPrototype.elsep;
            <artifact> val x$105: scala.meta.internal.ast.Term = this.internalPrototype.elsep;
            <artifact> val x$106: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$107: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$21.internalCopy$default$3;
            <artifact> val x$108: scala.meta.Origin = qual$21.internalCopy$default$4;
            qual$21.internalCopy(x$105, x$106, x$107, x$108)
          })
        }
      else
        (): Unit);
      this._elsep
    }
  }
};
```
