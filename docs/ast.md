### Internal structure of scala.meta ASTs

We use macro annotations to generate swaths of boilerplate that are required for our abstract syntax trees
to be efficient and convenient. Here's the code that we write in [Trees.scala](/scalameta/src/main/scala/scala/meta/Trees.scala):

```
@ast class If(cond: Term, thenp: Term, elsep: Term) extends Term
```

Here's the code generated by the `@ast` macro annotation:

```
@new _root_.org.scalameta.ast.internal.astClass() @new _root_.org.scalameta.adt.Internal.leafClass()
abstract trait If extends Term with _root_.scala.Product {
  @new _root_.org.scalameta.ast.internal.astField() def cond: Term;
  @new _root_.org.scalameta.ast.internal.astField() def thenp: Term;
  @new _root_.org.scalameta.ast.internal.astField() def elsep: Term;
  override type ThisType <: If
}
@new _root_.org.scalameta.ast.internal.astCompanion() @new _root_.org.scalameta.adt.Internal.leafCompanion()
object If extends scala.AnyRef {
  def internalTag: _root_.scala.Int = _root_.org.scalameta.adt.Internal.calculateTag[If];
  def apply(cond: Term, thenp: Term, elsep: Term, origin: _root_.scala.meta.Origin = _root_.scala.meta.Origin.None): If = {
    def internal(cond: Term, thenp: Term, elsep: Term, origin: _root_.scala.meta.Origin): If = {
      _root_.org.scalameta.ast.internal.hierarchyCheck[If];
      _root_.org.scalameta.adt.Internal.nullCheck(cond);
      _root_.org.scalameta.adt.Internal.nullCheck(thenp);
      _root_.org.scalameta.adt.Internal.nullCheck(elsep);
      _root_.org.scalameta.adt.Internal.emptyCheck(cond);
      _root_.org.scalameta.adt.Internal.emptyCheck(thenp);
      _root_.org.scalameta.adt.Internal.emptyCheck(elsep);
      val node = new Impl(null, null, _root_.scala.collection.immutable.Nil, origin)(_root_.org.scalameta.ast.internal.initParam(cond), _root_.org.scalameta.ast.internal.initParam(thenp), _root_.org.scalameta.ast.internal.initParam(elsep));
      _root_.org.scalameta.ast.internal.storeField(node._cond, cond);
      _root_.org.scalameta.ast.internal.storeField(node._thenp, thenp);
      _root_.org.scalameta.ast.internal.storeField(node._elsep, elsep);
      node
    };
    internal(cond, thenp, elsep, origin)
  };
  @new _root_.scala.inline() final def unapply(x: If): Option[scala.Tuple3[Term, Term, Term]] = if (x.$eq$eq(null))
    _root_.scala.None
  else
    _root_.scala.Some(scala.Tuple3(x.cond, x.thenp, x.elsep));
  import _root_.scala.language.experimental.{macros=>prettyPlease};
  import _root_.scala.language.implicitConversions;
  implicit <macro> def interfaceToApi(interface: If): Api = _root_.org.scalameta.ast.internal.Macros.interfaceToApi[If, Api];
  abstract trait Api extends If {
    def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep, origin: _root_.scala.meta.Origin = _root_.scala.meta.Origin.Transformed(this)): ThisType = If.apply(cond, thenp, elsep, origin);
    override type ThisType = If;
    override def internalTag: _root_.scala.Int = If.internalTag;
    override def productPrefix: _root_.scala.Predef.String = _root_.org.scalameta.ast.internal.productPrefix[ThisType];
    override def productArity: _root_.scala.Int = 3;
    override def productElement(n: _root_.scala.Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
    };
    override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this)
  };
  private[If] final class Impl (
    protected val internalPrototype: If,
    protected val internalParent: _root_.scala.meta.Tree,
    protected val internalScratchpad: _root_.scala.collection.immutable.Seq[Any],
    protected val internalOrigin: _root_.scala.meta.Origin
  )(
    var _cond: Term,
    var _thenp: Term,
    var _elsep: Term
  ) extends If.Api {
    private[meta] def internalCopy(prototype: _root_.scala.meta.Tree = this, parent: _root_.scala.meta.Tree = internalParent, scratchpad: _root_.scala.collection.immutable.Seq[Any] = internalScratchpad, origin: _root_.scala.meta.Origin = internalOrigin): ThisType = new Impl(prototype.asInstanceOf[ThisType], parent, scratchpad, origin)(_root_.org.scalameta.ast.internal.initField(this._cond), _root_.org.scalameta.ast.internal.initField(this._thenp), _root_.org.scalameta.ast.internal.initField(this._elsep));
    def parent: _root_.scala.Option[_root_.scala.meta.Tree] = if (internalParent.$bang$eq(null))
      _root_.scala.Some(internalParent)
    else
      _root_.scala.None;
    def origin: _root_.scala.meta.Origin = internalOrigin;
    def cond: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._cond);
      this._cond
    };
    def thenp: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._thenp);
      this._thenp
    };
    def elsep: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._elsep);
      this._elsep
    }
  };
  @new _root_.org.scalameta.ast.ast() private[meta] 
  class Unquote(tree: _root_.scala.Any) 
  extends If with _root_.scala.meta.internal.ast.Quasi.Unquote with Term.Unquote {
    override def cond: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported unquoting position");
    override def thenp: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported unquoting position");
    override def elsep: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported unquoting position");
    def pt: _root_.java.lang.Class[_$51] forSome {
      <synthetic> type _$51
    } = _root_.scala.Predef.classOf[If]
  };
  @new _root_.org.scalameta.ast.ast() private[meta] 
  class Ellipsis(tree: _root_.scala.meta.internal.ast.Tree, rank: _root_.scala.Int) 
  extends If with _root_.scala.meta.internal.ast.Quasi.Ellipsis with Term.Ellipsis {
    override def cond: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported splicing position");
    override def thenp: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported splicing position");
    override def elsep: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported splicing position");
    def pt: _root_.java.lang.Class[_$52] forSome {
      <synthetic> type _$52
    } = _root_.org.scalameta.runtime.arrayClass(_root_.scala.Predef.classOf[If], rank)
  }
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass abstract trait If extends AnyRef with scala.meta.internal.ast.Term with Product {
  @org.scalameta.ast.internal.astField def cond: scala.meta.internal.ast.Term;
  @org.scalameta.ast.internal.astField def thenp: scala.meta.internal.ast.Term;
  @org.scalameta.ast.internal.astField def elsep: scala.meta.internal.ast.Term;
  override type ThisType <: scala.meta.internal.ast.Term.If
};
@@<?> @@<?> object If extends scala.AnyRef {
  def <init>(): scala.meta.internal.ast.Term.If.type = {
    If.super.<init>();
    ()
  };
  def internalTag: Int = 58;
  def apply(cond: scala.meta.internal.ast.Term, thenp: scala.meta.internal.ast.Term, elsep: scala.meta.internal.ast.Term, origin: scala.meta.Origin = scala.meta.Origin.None): scala.meta.internal.ast.Term.If = {
    def internal(cond: scala.meta.internal.ast.Term, thenp: scala.meta.internal.ast.Term, elsep: scala.meta.internal.ast.Term, origin: scala.meta.Origin): scala.meta.internal.ast.Term.If = {
      ((): Unit);
      ({
        val result$macro$337: Boolean = cond.!=(null);
        if (result$macro$337)
          scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("cond is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$336 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("cond.!=(null)", failures$macro$336, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("cond", cond)))
      }: Unit);
      ({
        val result$macro$339: Boolean = thenp.!=(null);
        if (result$macro$339)
          scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("thenp is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$338 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("thenp.!=(null)", failures$macro$338, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("thenp", thenp)))
      }: Unit);
      ({
        val result$macro$341: Boolean = elsep.!=(null);
        if (result$macro$341)
          scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("elsep is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$340 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("elsep.!=(null)", failures$macro$340, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("elsep", elsep)))
      }: Unit);
      ();
      ();
      ();
      val node: scala.meta.internal.ast.Term.If.Impl = new If.this.Impl(null, null, scala.collection.immutable.Nil, origin)((null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term));
      (node._cond_=(cond.internalCopy(cond, node, cond.internalCopy$default$3, cond.internalCopy$default$4)): Unit);
      (node._thenp_=(thenp.internalCopy(thenp, node, thenp.internalCopy$default$3, thenp.internalCopy$default$4)): Unit);
      (node._elsep_=(elsep.internalCopy(elsep, node, elsep.internalCopy$default$3, elsep.internalCopy$default$4)): Unit);
      node
    };
    internal(cond, thenp, elsep, origin)
  };
  <synthetic> def apply$default$4: scala.meta.Origin = scala.meta.Origin.None;
  @inline final def unapply(x: scala.meta.internal.ast.Term.If): Option[(scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term)] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[(scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term)](scala.Tuple3.apply[scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term](x.cond, x.thenp, x.elsep));
  import scala.language.experimental.{macros=>prettyPlease};
  import scala.language.implicitConversions;
  @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalameta.ast.internal$Macros", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.internal.ast.Term.If, scala.meta.internal.ast.Term.If.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.internal.ast.Term.If): scala.meta.internal.ast.Term.If.Api = new org.scalameta.ast.internal.Macros(null).interfaceToApi[scala.meta.internal.ast.Term.If, scala.meta.internal.ast.Term.If.Api];
  abstract trait Api extends AnyRef with scala.meta.internal.ast.Term.If {
    def /*Api*/$init$(): Unit = {
      ()
    };
    def copy(cond: scala.meta.internal.ast.Term = this.cond, thenp: scala.meta.internal.ast.Term = this.thenp, elsep: scala.meta.internal.ast.Term = this.elsep, origin: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this)): Api.this.ThisType = Term.this.If.apply(cond, thenp, elsep, origin);
    <synthetic> def copy$default$1: scala.meta.internal.ast.Term = this.cond;
    <synthetic> def copy$default$2: scala.meta.internal.ast.Term = this.thenp;
    <synthetic> def copy$default$3: scala.meta.internal.ast.Term = this.elsep;
    <synthetic> def copy$default$4: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this);
    override type ThisType = scala.meta.internal.ast.Term.If;
    override def internalTag: Int = Term.this.If.internalTag;
    override def productPrefix: String = ("Term.If": String);
    override def productArity: Int = 3;
    override def productElement(n: Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
    };
    override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
  };
  final private[If] class Impl extends AnyRef with scala.meta.internal.ast.Term.If.Api {
    <paramaccessor> private[this] val internalPrototype: scala.meta.internal.ast.Term.If = _;
    <stable> <accessor> <paramaccessor> protected def internalPrototype: scala.meta.internal.ast.Term.If = Impl.this.internalPrototype;
    <paramaccessor> private[this] val internalParent: scala.meta.Tree = _;
    <stable> <accessor> <paramaccessor> protected def internalParent: scala.meta.Tree = Impl.this.internalParent;
    <paramaccessor> private[this] val internalScratchpad: scala.collection.immutable.Seq[Any] = _;
    <stable> <accessor> <paramaccessor> protected def internalScratchpad: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad;
    <paramaccessor> private[this] val internalOrigin: scala.meta.Origin = _;
    <stable> <accessor> <paramaccessor> protected def internalOrigin: scala.meta.Origin = Impl.this.internalOrigin;
    <paramaccessor> private[this] var _cond: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _cond: scala.meta.internal.ast.Term = Impl.this._cond;
    <accessor> <paramaccessor> def _cond_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._cond = x$1;
    <paramaccessor> private[this] var _thenp: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _thenp: scala.meta.internal.ast.Term = Impl.this._thenp;
    <accessor> <paramaccessor> def _thenp_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._thenp = x$1;
    <paramaccessor> private[this] var _elsep: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _elsep: scala.meta.internal.ast.Term = Impl.this._elsep;
    <accessor> <paramaccessor> def _elsep_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._elsep = x$1;
    def <init>(internalPrototype: scala.meta.internal.ast.Term.If, internalParent: scala.meta.Tree, internalScratchpad: scala.collection.immutable.Seq[Any], internalOrigin: scala.meta.Origin)(_cond: scala.meta.internal.ast.Term, _thenp: scala.meta.internal.ast.Term, _elsep: scala.meta.internal.ast.Term): scala.meta.internal.ast.Term.If.Impl = {
      Impl.super.<init>();
      ()
    };
    private[meta] def internalCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.internalParent, scratchpad: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad, origin: scala.meta.Origin = Impl.this.internalOrigin): Impl.this.ThisType = new If.this.Impl(prototype.asInstanceOf[Impl.this.ThisType], parent, scratchpad, origin)((null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term));
    override <synthetic> def internalCopy$default$1: scala.meta.Tree = this;
    override <synthetic> def internalCopy$default$2: scala.meta.Tree = Impl.this.internalParent;
    override <synthetic> def internalCopy$default$3: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad;
    override <synthetic> def internalCopy$default$4: scala.meta.Origin = Impl.this.internalOrigin;
    def parent: Option[scala.meta.Tree] = if (Impl.this.internalParent.!=(null))
      scala.Some.apply[scala.meta.Tree](Impl.this.internalParent)
    else
      scala.None;
    def origin: scala.meta.Origin = Impl.this.internalOrigin;
    def cond: scala.meta.internal.ast.Term = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.cond");
          this._cond_=({
            <artifact> val qual$41: scala.meta.internal.ast.Term = this.internalPrototype.cond;
            <artifact> val x$186: scala.meta.internal.ast.Term = this.internalPrototype.cond;
            <artifact> val x$187: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$188: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$41.internalCopy$default$3;
            <artifact> val x$189: scala.meta.Origin = qual$41.internalCopy$default$4;
            qual$41.internalCopy(x$186, x$187, x$188, x$189)
          })
        }
      else
        (): Unit);
      this._cond
    };
    def thenp: scala.meta.internal.ast.Term = {
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.thenp");
          this._thenp_=({
            <artifact> val qual$42: scala.meta.internal.ast.Term = this.internalPrototype.thenp;
            <artifact> val x$190: scala.meta.internal.ast.Term = this.internalPrototype.thenp;
            <artifact> val x$191: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$192: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$42.internalCopy$default$3;
            <artifact> val x$193: scala.meta.Origin = qual$42.internalCopy$default$4;
            qual$42.internalCopy(x$190, x$191, x$192, x$193)
          })
        }
      else
        (): Unit);
      this._thenp
    };
    def elsep: scala.meta.internal.ast.Term = {
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.elsep");
          this._elsep_=({
            <artifact> val qual$43: scala.meta.internal.ast.Term = this.internalPrototype.elsep;
            <artifact> val x$194: scala.meta.internal.ast.Term = this.internalPrototype.elsep;
            <artifact> val x$195: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$196: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$43.internalCopy$default$3;
            <artifact> val x$197: scala.meta.Origin = qual$43.internalCopy$default$4;
            qual$43.internalCopy(x$194, x$195, x$196, x$197)
          })
        }
      else
        (): Unit);
      this._elsep
    }
  };
  @org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass final private[meta] class Unquote extends AnyRef with scala.meta.internal.ast.Term.If with meta.internal.ast.Quasi.Unquote with scala.meta.internal.ast.Term.Unquote with Product {
    <paramaccessor> private[this] val internalPrototype: scala.meta.internal.ast.Term.If.Unquote = _;
    <stable> <accessor> <paramaccessor> protected def internalPrototype: scala.meta.internal.ast.Term.If.Unquote = Unquote.this.internalPrototype;
    <paramaccessor> private[this] val internalParent: scala.meta.Tree = _;
    <stable> <accessor> <paramaccessor> protected def internalParent: scala.meta.Tree = Unquote.this.internalParent;
    <paramaccessor> private[this] val internalScratchpad: scala.collection.immutable.Seq[Any] = _;
    <stable> <accessor> <paramaccessor> protected def internalScratchpad: scala.collection.immutable.Seq[Any] = Unquote.this.internalScratchpad;
    <paramaccessor> private[this] val internalOrigin: scala.meta.Origin = _;
    <stable> <accessor> <paramaccessor> protected def internalOrigin: scala.meta.Origin = Unquote.this.internalOrigin;
    <paramaccessor> private[this] var _tree: Any = _;
    <accessor> <paramaccessor> def _tree: Any = Unquote.this._tree;
    <accessor> <paramaccessor> def _tree_=(x$1: Any): Unit = Unquote.this._tree = x$1;
    def <init>(internalPrototype: scala.meta.internal.ast.Term.If.Unquote, internalParent: scala.meta.Tree, internalScratchpad: scala.collection.immutable.Seq[Any], internalOrigin: scala.meta.Origin)(_tree: Any): scala.meta.internal.ast.Term.If.Unquote = {
      Unquote.super.<init>();
      ()
    };
    private[meta] def internalCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Unquote.this.internalParent, scratchpad: scala.collection.immutable.Seq[Any] = Unquote.this.internalScratchpad, origin: scala.meta.Origin = Unquote.this.internalOrigin): Unquote.this.ThisType = new If.this.Unquote(prototype.asInstanceOf[Unquote.this.ThisType], parent, scratchpad, origin)((this._tree: Any));
    override <synthetic> def internalCopy$default$1: scala.meta.Tree = this;
    override <synthetic> def internalCopy$default$2: scala.meta.Tree = Unquote.this.internalParent;
    override <synthetic> def internalCopy$default$3: scala.collection.immutable.Seq[Any] = Unquote.this.internalScratchpad;
    override <synthetic> def internalCopy$default$4: scala.meta.Origin = Unquote.this.internalOrigin;
    def parent: Option[scala.meta.Tree] = if (Unquote.this.internalParent.!=(null))
      scala.Some.apply[scala.meta.Tree](Unquote.this.internalParent)
    else
      scala.None;
    def origin: scala.meta.Origin = Unquote.this.internalOrigin;
    def tree: Any = {
      ((): Unit);
      this._tree
    };
    override def cond: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported unquoting position");
    override def thenp: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported unquoting position");
    override def elsep: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported unquoting position");
    def pt: Class[_] = classOf[scala.meta.internal.ast.Term$$If];
    def copy(tree: Any = this.tree, origin: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this)): Unquote.this.ThisType = If.this.Unquote.apply(tree, origin);
    <synthetic> def copy$default$1: Any = this.tree;
    <synthetic> def copy$default$2: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this);
    override type ThisType = scala.meta.internal.ast.Term.If.Unquote;
    override def internalTag: Int = If.this.Unquote.internalTag;
    override def productPrefix: String = ("Term.If.Unquote": String);
    override def productArity: Int = 1;
    override def productElement(n: Int): Any = n match {
      case 0 => this.tree
      case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
    };
    override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
  };
  @@<?> @@<?> private[meta] object Unquote extends scala.AnyRef {
    def <init>(): scala.meta.internal.ast.Term.If.Unquote.type = {
      Unquote.super.<init>();
      ()
    };
    def internalTag: Int = 59;
    def apply(tree: Any, origin: scala.meta.Origin = scala.meta.Origin.None): scala.meta.internal.ast.Term.If.Unquote = {
      def internal(tree: Any, origin: scala.meta.Origin): scala.meta.internal.ast.Term.If.Unquote = {
        ((): Unit);
        ();
        ();
        val node: scala.meta.internal.ast.Term.If.Unquote = new If.this.Unquote(null, null, scala.collection.immutable.Nil, origin)((tree: Any));
        ((): Unit);
        node
      };
      internal(tree, origin)
    };
    <synthetic> def apply$default$2: scala.meta.Origin = scala.meta.Origin.None;
    @inline final def unapply(x: scala.meta.internal.ast.Term.If.Unquote): Option[Any] = if (x.==(null))
      scala.None
    else
      scala.Some.apply[Any](x.tree)
  };
  @org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass final private[meta] class Ellipsis extends AnyRef with scala.meta.internal.ast.Term.If with meta.internal.ast.Quasi.Ellipsis with scala.meta.internal.ast.Term.Ellipsis with Product {
    <paramaccessor> private[this] val internalPrototype: scala.meta.internal.ast.Term.If.Ellipsis = _;
    <stable> <accessor> <paramaccessor> protected def internalPrototype: scala.meta.internal.ast.Term.If.Ellipsis = Ellipsis.this.internalPrototype;
    <paramaccessor> private[this] val internalParent: scala.meta.Tree = _;
    <stable> <accessor> <paramaccessor> protected def internalParent: scala.meta.Tree = Ellipsis.this.internalParent;
    <paramaccessor> private[this] val internalScratchpad: scala.collection.immutable.Seq[Any] = _;
    <stable> <accessor> <paramaccessor> protected def internalScratchpad: scala.collection.immutable.Seq[Any] = Ellipsis.this.internalScratchpad;
    <paramaccessor> private[this] val internalOrigin: scala.meta.Origin = _;
    <stable> <accessor> <paramaccessor> protected def internalOrigin: scala.meta.Origin = Ellipsis.this.internalOrigin;
    <paramaccessor> private[this] var _tree: scala.meta.internal.ast.Tree = _;
    <accessor> <paramaccessor> def _tree: scala.meta.internal.ast.Tree = Ellipsis.this._tree;
    <accessor> <paramaccessor> def _tree_=(x$1: scala.meta.internal.ast.Tree): Unit = Ellipsis.this._tree = x$1;
    <paramaccessor> private[this] var _rank: Int = _;
    <accessor> <paramaccessor> def _rank: Int = Ellipsis.this._rank;
    <accessor> <paramaccessor> def _rank_=(x$1: Int): Unit = Ellipsis.this._rank = x$1;
    def <init>(internalPrototype: scala.meta.internal.ast.Term.If.Ellipsis, internalParent: scala.meta.Tree, internalScratchpad: scala.collection.immutable.Seq[Any], internalOrigin: scala.meta.Origin)(_tree: scala.meta.internal.ast.Tree, _rank: Int): scala.meta.internal.ast.Term.If.Ellipsis = {
      Ellipsis.super.<init>();
      ()
    };
    private[meta] def internalCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Ellipsis.this.internalParent, scratchpad: scala.collection.immutable.Seq[Any] = Ellipsis.this.internalScratchpad, origin: scala.meta.Origin = Ellipsis.this.internalOrigin): Ellipsis.this.ThisType = new If.this.Ellipsis(prototype.asInstanceOf[Ellipsis.this.ThisType], parent, scratchpad, origin)((null: scala.meta.internal.ast.Tree), (this._rank: Int));
    override <synthetic> def internalCopy$default$1: scala.meta.Tree = this;
    override <synthetic> def internalCopy$default$2: scala.meta.Tree = Ellipsis.this.internalParent;
    override <synthetic> def internalCopy$default$3: scala.collection.immutable.Seq[Any] = Ellipsis.this.internalScratchpad;
    override <synthetic> def internalCopy$default$4: scala.meta.Origin = Ellipsis.this.internalOrigin;
    def parent: Option[scala.meta.Tree] = if (Ellipsis.this.internalParent.!=(null))
      scala.Some.apply[scala.meta.Tree](Ellipsis.this.internalParent)
    else
      scala.None;
    def origin: scala.meta.Origin = Ellipsis.this.internalOrigin;
    def tree: scala.meta.internal.ast.Tree = {
      (if (this._tree.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Ellipsis.tree");
          this._tree_=({
            <artifact> val qual$44: scala.meta.internal.ast.Tree = this.internalPrototype.tree;
            <artifact> val x$198: scala.meta.internal.ast.Tree = this.internalPrototype.tree;
            <artifact> val x$199: scala.meta.internal.ast.Term.If.Ellipsis = this;
            <artifact> val x$200: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$44.internalCopy$default$3;
            <artifact> val x$201: scala.meta.Origin = qual$44.internalCopy$default$4;
            qual$44.internalCopy(x$198, x$199, x$200, x$201)
          })
        }
      else
        (): Unit);
      this._tree
    };
    def rank: Int = {
      ((): Unit);
      this._rank
    };
    override def cond: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported splicing position");
    override def thenp: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported splicing position");
    override def elsep: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported splicing position");
    def pt: Class[_] = org.scalameta.runtime.`package`.arrayClass(classOf[scala.meta.internal.ast.Term$$If], Ellipsis.this.rank);
    def copy(tree: scala.meta.internal.ast.Tree = this.tree, rank: Int = this.rank, origin: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this)): Ellipsis.this.ThisType = If.this.Ellipsis.apply(tree, rank, origin);
    <synthetic> def copy$default$1: scala.meta.internal.ast.Tree = this.tree;
    <synthetic> def copy$default$2: Int = this.rank;
    <synthetic> def copy$default$3: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this);
    override type ThisType = scala.meta.internal.ast.Term.If.Ellipsis;
    override def internalTag: Int = If.this.Ellipsis.internalTag;
    override def productPrefix: String = ("Term.If.Ellipsis": String);
    override def productArity: Int = 2;
    override def productElement(n: Int): Any = n match {
      case 0 => this.tree
      case 1 => this.rank
      case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
    };
    override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
  };
  @@<?> @@<?> private[meta] object Ellipsis extends scala.AnyRef {
    def <init>(): scala.meta.internal.ast.Term.If.Ellipsis.type = {
      Ellipsis.super.<init>();
      ()
    };
    def internalTag: Int = 60;
    def apply(tree: scala.meta.internal.ast.Tree, rank: Int, origin: scala.meta.Origin = scala.meta.Origin.None): scala.meta.internal.ast.Term.If.Ellipsis = {
      def internal(tree: scala.meta.internal.ast.Tree, rank: Int, origin: scala.meta.Origin): scala.meta.internal.ast.Term.If.Ellipsis = {
        ((): Unit);
        ({
          val result$macro$343: Boolean = tree.!=(null);
          if (result$macro$343)
            scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
          else
            scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("tree is equal to null"))
        } match {
          case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
          case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$342 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("tree.!=(null)", failures$macro$342, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Tree](scala.Tuple2.apply[String, scala.meta.internal.ast.Tree]("tree", tree)))
        }: Unit);
        ();
        ();
        ();
        val node: scala.meta.internal.ast.Term.If.Ellipsis = new If.this.Ellipsis(null, null, scala.collection.immutable.Nil, origin)((null: scala.meta.internal.ast.Tree), (rank: Int));
        (node._tree_=(tree.internalCopy(tree, node, tree.internalCopy$default$3, tree.internalCopy$default$4)): Unit);
        ((): Unit);
        node
      };
      internal(tree, rank, origin)
    };
    <synthetic> def apply$default$3: scala.meta.Origin = scala.meta.Origin.None;
    @inline final def unapply(x: scala.meta.internal.ast.Term.If.Ellipsis): Option[(scala.meta.internal.ast.Tree, Int)] = if (x.==(null))
      scala.None
    else
      scala.Some.apply[(scala.meta.internal.ast.Tree, Int)](scala.Tuple2.apply[scala.meta.internal.ast.Tree, Int](x.tree, x.rank))
  }
};
```
