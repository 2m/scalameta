### Internal structure of scala.meta ASTs

We use macro annotations to generate swaths of boilerplate that make our abstract syntax trees efficient and convenient. 
Here's the code that we write in [Trees.scala](/scalameta/src/main/scala/scala/meta/Trees.scala):

```
@ast class If(cond: Term, thenp: Term, elsep: Term) extends Term
```

Here's the code generated by the `@ast` macro annotation:

```
@new _root_.org.scalameta.ast.internal.astClass() @new _root_.org.scalameta.adt.Internal.leafClass()
abstract trait If extends Term with _root_.scala.Product {
  @new _root_.org.scalameta.ast.internal.astField() def cond: Term;
  @new _root_.org.scalameta.ast.internal.astField() def thenp: Term;
  @new _root_.org.scalameta.ast.internal.astField() def elsep: Term;
  override type ThisType <: If
}
@new _root_.org.scalameta.ast.internal.astCompanion() @new _root_.org.scalameta.adt.Internal.leafCompanion()
object If extends scala.AnyRef {
  def internalTag: _root_.scala.Int = _root_.org.scalameta.adt.Internal.calculateTag[If];
  def apply(cond: Term, thenp: Term, elsep: Term, origin: _root_.scala.meta.Origin = _root_.scala.meta.Origin.None): If = {
    def internal(cond: Term, thenp: Term, elsep: Term, origin: _root_.scala.meta.Origin): If = {
      _root_.org.scalameta.ast.internal.hierarchyCheck[If];
      _root_.org.scalameta.adt.Internal.nullCheck(cond);
      _root_.org.scalameta.adt.Internal.nullCheck(thenp);
      _root_.org.scalameta.adt.Internal.nullCheck(elsep);
      _root_.org.scalameta.adt.Internal.emptyCheck(cond);
      _root_.org.scalameta.adt.Internal.emptyCheck(thenp);
      _root_.org.scalameta.adt.Internal.emptyCheck(elsep);
      val node = new Impl(null, null, _root_.scala.collection.immutable.Nil, origin)(_root_.org.scalameta.ast.internal.initParam(cond), _root_.org.scalameta.ast.internal.initParam(thenp), _root_.org.scalameta.ast.internal.initParam(elsep));
      _root_.org.scalameta.ast.internal.storeField(node._cond, cond);
      _root_.org.scalameta.ast.internal.storeField(node._thenp, thenp);
      _root_.org.scalameta.ast.internal.storeField(node._elsep, elsep);
      node
    };
    internal(cond, thenp, elsep, origin)
  };
  @new _root_.scala.inline() final def unapply(x: If): Option[scala.Tuple3[Term, Term, Term]] = if (x.$eq$eq(null))
    _root_.scala.None
  else
    _root_.scala.Some(scala.Tuple3(x.cond, x.thenp, x.elsep));
  import _root_.scala.language.experimental.{macros=>prettyPlease};
  import _root_.scala.language.implicitConversions;
  implicit <macro> def interfaceToApi(interface: If): Api = _root_.org.scalameta.ast.internal.Macros.interfaceToApi[If, Api];
  abstract trait Api extends If {
    def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep, origin: _root_.scala.meta.Origin = _root_.scala.meta.Origin.Transformed(this)): ThisType = If.apply(cond, thenp, elsep, origin);
    override type ThisType = If;
    override def internalTag: _root_.scala.Int = If.internalTag;
    override def productPrefix: _root_.scala.Predef.String = _root_.org.scalameta.ast.internal.productPrefix[ThisType];
    override def productArity: _root_.scala.Int = 3;
    override def productElement(n: _root_.scala.Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
    };
    override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this)
  };
  private[If] final class Impl (
    protected val internalPrototype: If,
    protected val internalParent: _root_.scala.meta.Tree,
    protected val internalScratchpad: _root_.scala.collection.immutable.Seq[Any],
    protected val internalOrigin: _root_.scala.meta.Origin
  )(
    var _cond: Term,
    var _thenp: Term,
    var _elsep: Term
  ) extends If.Api {
    private[meta] def internalCopy(prototype: _root_.scala.meta.Tree = this, parent: _root_.scala.meta.Tree = internalParent, scratchpad: _root_.scala.collection.immutable.Seq[Any] = internalScratchpad, origin: _root_.scala.meta.Origin = internalOrigin): ThisType = new Impl(prototype.asInstanceOf[ThisType], parent, scratchpad, origin)(_root_.org.scalameta.ast.internal.initField(this._cond), _root_.org.scalameta.ast.internal.initField(this._thenp), _root_.org.scalameta.ast.internal.initField(this._elsep));
    def parent: _root_.scala.Option[_root_.scala.meta.Tree] = if (internalParent.$bang$eq(null))
      _root_.scala.Some(internalParent)
    else
      _root_.scala.None;
    def origin: _root_.scala.meta.Origin = internalOrigin;
    def cond: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._cond);
      this._cond
    };
    def thenp: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._thenp);
      this._thenp
    };
    def elsep: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._elsep);
      this._elsep
    }
  };
  @new _root_.org.scalameta.ast.internal.astClass() @new _root_.org.scalameta.adt.Internal.leafClass() 
  abstract private[meta] trait Unquote extends If with _root_.scala.meta.internal.ast.Quasi.Unquote with Term.Unquote with _root_.scala.Product {
    @new _root_.org.scalameta.ast.internal.astField() def tree: _root_.scala.Any;
    override type ThisType <: Unquote
  }
  @new _root_.org.scalameta.ast.internal.astCompanion() @new _root_.org.scalameta.adt.Internal.leafCompanion() 
  object Unquote extends scala.AnyRef {
    def internalTag: _root_.scala.Int = _root_.org.scalameta.adt.Internal.calculateTag[Unquote];
    def apply(tree: _root_.scala.Any, origin: _root_.scala.meta.Origin = _root_.scala.meta.Origin.None): Unquote = {
      def internal(tree: _root_.scala.Any, origin: _root_.scala.meta.Origin): Unquote = {
        _root_.org.scalameta.ast.internal.hierarchyCheck[Unquote];
        _root_.org.scalameta.adt.Internal.nullCheck(tree);
        _root_.org.scalameta.adt.Internal.emptyCheck(tree);
        val node = new Impl(null, null, _root_.scala.collection.immutable.Nil, origin)(_root_.org.scalameta.ast.internal.initParam(tree));
        _root_.org.scalameta.ast.internal.storeField(node._tree, tree);
        node
      };
      internal(tree, origin)
    };
    @new _root_.scala.inline() final def unapply(x: Unquote): Option[_root_.scala.Any] = if (x.$eq$eq(null))
      _root_.scala.None
    else
      _root_.scala.Some(x.tree);
    import _root_.scala.language.experimental.{macros=>prettyPlease};
    import _root_.scala.language.implicitConversions;
    implicit <macro> def interfaceToApi(interface: Unquote): Api = _root_.org.scalameta.ast.internal.Macros.interfaceToApi[Unquote, Api];
    abstract trait Api extends Unquote {
      override def cond: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported unquoting position");
      override def thenp: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported unquoting position");
      override def elsep: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported unquoting position");
      def pt: _root_.java.lang.Class[_$129] forSome {
        <synthetic> type _$129
      } = _root_.scala.Predef.classOf[If];
      def copy(tree: _root_.scala.Any = this.tree, origin: _root_.scala.meta.Origin = _root_.scala.meta.Origin.Transformed(this)): ThisType = Unquote.apply(tree, origin);
      override type ThisType = Unquote;
      override def internalTag: _root_.scala.Int = Unquote.internalTag;
      override def productPrefix: _root_.scala.Predef.String = _root_.org.scalameta.ast.internal.productPrefix[ThisType];
      override def productArity: _root_.scala.Int = 1;
      override def productElement(n: _root_.scala.Int): Any = n match {
        case 0 => this.tree
        case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
      };
      override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this)
    };
    final private[Unquote] class Impl(
      protected val internalPrototype: Unquote,
      protected val internalParent: _root_.scala.meta.Tree,
      protected val internalScratchpad: _root_.scala.collection.immutable.Seq[Any],
      protected val internalOrigin: _root_.scala.meta.Origin
    )(
      var _tree: _root_.scala.Any
    ) extends Unquote.Api {
      private[meta] def internalCopy(prototype: _root_.scala.meta.Tree = this, parent: _root_.scala.meta.Tree = internalParent, scratchpad: _root_.scala.collection.immutable.Seq[Any] = internalScratchpad, origin: _root_.scala.meta.Origin = internalOrigin): ThisType = new Impl(prototype.asInstanceOf[ThisType], parent, scratchpad, origin)(_root_.org.scalameta.ast.internal.initField(this._tree));
      def parent: _root_.scala.Option[_root_.scala.meta.Tree] = if (internalParent.$bang$eq(null))
        _root_.scala.Some(internalParent)
      else
        _root_.scala.None;
      def origin: _root_.scala.meta.Origin = internalOrigin;
      def tree: _root_.scala.Any = {
        _root_.org.scalameta.ast.internal.loadField(this._tree);
        this._tree
      }
    }
  }
  @new _root_.org.scalameta.ast.internal.astClass() @new _root_.org.scalameta.adt.Internal.leafClass() 
  abstract private[meta] trait Ellipsis extends If with _root_.scala.meta.internal.ast.Quasi.Ellipsis with Term.Ellipsis with _root_.scala.Product {
    @new _root_.org.scalameta.ast.internal.astField() def tree: _root_.scala.meta.internal.ast.Tree;
    @new _root_.org.scalameta.ast.internal.astField() def rank: _root_.scala.Int;
    override type ThisType <: Ellipsis
  }
  @new _root_.org.scalameta.ast.internal.astCompanion() @new _root_.org.scalameta.adt.Internal.leafCompanion() 
  object Ellipsis extends scala.AnyRef {
    def internalTag: _root_.scala.Int = _root_.org.scalameta.adt.Internal.calculateTag[Ellipsis];
    def apply(tree: _root_.scala.meta.internal.ast.Tree, rank: _root_.scala.Int, origin: _root_.scala.meta.Origin = _root_.scala.meta.Origin.None): Ellipsis = {
      def internal(tree: _root_.scala.meta.internal.ast.Tree, rank: _root_.scala.Int, origin: _root_.scala.meta.Origin): Ellipsis = {
        _root_.org.scalameta.ast.internal.hierarchyCheck[Ellipsis];
        _root_.org.scalameta.adt.Internal.nullCheck(tree);
        _root_.org.scalameta.adt.Internal.nullCheck(rank);
        _root_.org.scalameta.adt.Internal.emptyCheck(tree);
        _root_.org.scalameta.adt.Internal.emptyCheck(rank);
        val node = new Impl(null, null, _root_.scala.collection.immutable.Nil, origin)(_root_.org.scalameta.ast.internal.initParam(tree), _root_.org.scalameta.ast.internal.initParam(rank));
        _root_.org.scalameta.ast.internal.storeField(node._tree, tree);
        _root_.org.scalameta.ast.internal.storeField(node._rank, rank);
        node
      };
      internal(tree, rank, origin)
    };
    @new _root_.scala.inline() final def unapply(x: Ellipsis): Option[scala.Tuple2[_root_.scala.meta.internal.ast.Tree, _root_.scala.Int]] = if (x.$eq$eq(null))
      _root_.scala.None
    else
      _root_.scala.Some(scala.Tuple2(x.tree, x.rank));
    import _root_.scala.language.experimental.{macros=>prettyPlease};
    import _root_.scala.language.implicitConversions;
    implicit <macro> def interfaceToApi(interface: Ellipsis): Api = _root_.org.scalameta.ast.internal.Macros.interfaceToApi[Ellipsis, Api];
    abstract trait Api extends Ellipsis {
      override def cond: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported splicing position");
      override def thenp: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported splicing position");
      override def elsep: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException("unsupported splicing position");
      def pt: _root_.java.lang.Class[_$130] forSome {
        <synthetic> type _$130
      } = _root_.org.scalameta.runtime.arrayClass(_root_.scala.Predef.classOf[If], rank);
      def copy(tree: _root_.scala.meta.internal.ast.Tree = this.tree, rank: _root_.scala.Int = this.rank, origin: _root_.scala.meta.Origin = _root_.scala.meta.Origin.Transformed(this)): ThisType = Ellipsis.apply(tree, rank, origin);
      override type ThisType = Ellipsis;
      override def internalTag: _root_.scala.Int = Ellipsis.internalTag;
      override def productPrefix: _root_.scala.Predef.String = _root_.org.scalameta.ast.internal.productPrefix[ThisType];
      override def productArity: _root_.scala.Int = 2;
      override def productElement(n: _root_.scala.Int): Any = n match {
        case 0 => this.tree
        case 1 => this.rank
        case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
      };
      override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this)
    };
    final private[Ellipsis] class Impl(
      protected val internalPrototype: Ellipsis,
      protected val internalParent: _root_.scala.meta.Tree,
      protected val internalScratchpad: _root_.scala.collection.immutable.Seq[Any],
      protected val internalOrigin: _root_.scala.meta.Origin
    )(
      var _tree: _root_.scala.Any,
      var _rank: _root_.scala.Int
    ) extends Ellipsis.Api {
      private[meta] def internalCopy(prototype: _root_.scala.meta.Tree = this, parent: _root_.scala.meta.Tree = internalParent, scratchpad: _root_.scala.collection.immutable.Seq[Any] = internalScratchpad, origin: _root_.scala.meta.Origin = internalOrigin): ThisType = new Impl(prototype.asInstanceOf[ThisType], parent, scratchpad, origin)(_root_.org.scalameta.ast.internal.initField(this._tree), _root_.org.scalameta.ast.internal.initField(this._rank));
      def parent: _root_.scala.Option[_root_.scala.meta.Tree] = if (internalParent.$bang$eq(null))
        _root_.scala.Some(internalParent)
      else
        _root_.scala.None;
      def origin: _root_.scala.meta.Origin = internalOrigin;
      def tree: _root_.scala.meta.internal.ast.Tree = {
        _root_.org.scalameta.ast.internal.loadField(this._tree);
        this._tree
      };
      def rank: _root_.scala.Int = {
        _root_.org.scalameta.ast.internal.loadField(this._rank);
        this._rank
      }
    }
  }
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass abstract trait If extends AnyRef with scala.meta.internal.ast.Term with Product {
  @org.scalameta.ast.internal.astField def cond: scala.meta.internal.ast.Term;
  @org.scalameta.ast.internal.astField def thenp: scala.meta.internal.ast.Term;
  @org.scalameta.ast.internal.astField def elsep: scala.meta.internal.ast.Term;
  override type ThisType <: scala.meta.internal.ast.Term.If
};
@@<?> @@<?> object If extends scala.AnyRef {
  def <init>(): scala.meta.internal.ast.Term.If.type = {
    If.super.<init>();
    ()
  };
  def internalTag: Int = 144;
  def apply(cond: scala.meta.internal.ast.Term, thenp: scala.meta.internal.ast.Term, elsep: scala.meta.internal.ast.Term, origin: scala.meta.Origin = scala.meta.Origin.None): scala.meta.internal.ast.Term.If = {
    def internal(cond: scala.meta.internal.ast.Term, thenp: scala.meta.internal.ast.Term, elsep: scala.meta.internal.ast.Term, origin: scala.meta.Origin): scala.meta.internal.ast.Term.If = {
      ((): Unit);
      ({
        val result$macro$423: Boolean = cond.!=(null);
        if (result$macro$423)
          scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("cond is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$422 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("cond.!=(null)", failures$macro$422, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("cond", cond)))
      }: Unit);
      ({
        val result$macro$425: Boolean = thenp.!=(null);
        if (result$macro$425)
          scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("thenp is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$424 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("thenp.!=(null)", failures$macro$424, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("thenp", thenp)))
      }: Unit);
      ({
        val result$macro$427: Boolean = elsep.!=(null);
        if (result$macro$427)
          scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("elsep is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$426 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("elsep.!=(null)", failures$macro$426, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("elsep", elsep)))
      }: Unit);
      ();
      ();
      ();
      val node: scala.meta.internal.ast.Term.If.Impl = new If.this.Impl(null, null, scala.collection.immutable.Nil, origin)((null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term));
      (node._cond_=(cond.internalCopy(cond, node, cond.internalCopy$default$3, cond.internalCopy$default$4)): Unit);
      (node._thenp_=(thenp.internalCopy(thenp, node, thenp.internalCopy$default$3, thenp.internalCopy$default$4)): Unit);
      (node._elsep_=(elsep.internalCopy(elsep, node, elsep.internalCopy$default$3, elsep.internalCopy$default$4)): Unit);
      node
    };
    internal(cond, thenp, elsep, origin)
  };
  <synthetic> def apply$default$4: scala.meta.Origin = scala.meta.Origin.None;
  @inline final def unapply(x: scala.meta.internal.ast.Term.If): Option[(scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term)] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[(scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term)](scala.Tuple3.apply[scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term](x.cond, x.thenp, x.elsep));
  import scala.language.experimental.{macros=>prettyPlease};
  import scala.language.implicitConversions;
  @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalameta.ast.internal$Macros", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.internal.ast.Term.If, scala.meta.internal.ast.Term.If.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.internal.ast.Term.If): scala.meta.internal.ast.Term.If.Api = new org.scalameta.ast.internal.Macros(null).interfaceToApi[scala.meta.internal.ast.Term.If, scala.meta.internal.ast.Term.If.Api];
  abstract trait Api extends AnyRef with scala.meta.internal.ast.Term.If {
    def /*Api*/$init$(): Unit = {
      ()
    };
    def copy(cond: scala.meta.internal.ast.Term = this.cond, thenp: scala.meta.internal.ast.Term = this.thenp, elsep: scala.meta.internal.ast.Term = this.elsep, origin: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this)): Api.this.ThisType = Term.this.If.apply(cond, thenp, elsep, origin);
    <synthetic> def copy$default$1: scala.meta.internal.ast.Term = this.cond;
    <synthetic> def copy$default$2: scala.meta.internal.ast.Term = this.thenp;
    <synthetic> def copy$default$3: scala.meta.internal.ast.Term = this.elsep;
    <synthetic> def copy$default$4: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this);
    override type ThisType = scala.meta.internal.ast.Term.If;
    override def internalTag: Int = Term.this.If.internalTag;
    override def productPrefix: String = ("Term.If": String);
    override def productArity: Int = 3;
    override def productElement(n: Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
    };
    override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
  };
  final private[If] class Impl extends AnyRef with scala.meta.internal.ast.Term.If.Api {
    <paramaccessor> private[this] val internalPrototype: scala.meta.internal.ast.Term.If = _;
    <stable> <accessor> <paramaccessor> protected def internalPrototype: scala.meta.internal.ast.Term.If = Impl.this.internalPrototype;
    <paramaccessor> private[this] val internalParent: scala.meta.Tree = _;
    <stable> <accessor> <paramaccessor> protected def internalParent: scala.meta.Tree = Impl.this.internalParent;
    <paramaccessor> private[this] val internalScratchpad: scala.collection.immutable.Seq[Any] = _;
    <stable> <accessor> <paramaccessor> protected def internalScratchpad: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad;
    <paramaccessor> private[this] val internalOrigin: scala.meta.Origin = _;
    <stable> <accessor> <paramaccessor> protected def internalOrigin: scala.meta.Origin = Impl.this.internalOrigin;
    <paramaccessor> private[this] var _cond: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _cond: scala.meta.internal.ast.Term = Impl.this._cond;
    <accessor> <paramaccessor> def _cond_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._cond = x$1;
    <paramaccessor> private[this] var _thenp: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _thenp: scala.meta.internal.ast.Term = Impl.this._thenp;
    <accessor> <paramaccessor> def _thenp_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._thenp = x$1;
    <paramaccessor> private[this] var _elsep: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _elsep: scala.meta.internal.ast.Term = Impl.this._elsep;
    <accessor> <paramaccessor> def _elsep_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._elsep = x$1;
    def <init>(internalPrototype: scala.meta.internal.ast.Term.If, internalParent: scala.meta.Tree, internalScratchpad: scala.collection.immutable.Seq[Any], internalOrigin: scala.meta.Origin)(_cond: scala.meta.internal.ast.Term, _thenp: scala.meta.internal.ast.Term, _elsep: scala.meta.internal.ast.Term): scala.meta.internal.ast.Term.If.Impl = {
      Impl.super.<init>();
      ()
    };
    private[meta] def internalCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.internalParent, scratchpad: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad, origin: scala.meta.Origin = Impl.this.internalOrigin): Impl.this.ThisType = new If.this.Impl(prototype.asInstanceOf[Impl.this.ThisType], parent, scratchpad, origin)((null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term));
    override <synthetic> def internalCopy$default$1: scala.meta.Tree = this;
    override <synthetic> def internalCopy$default$2: scala.meta.Tree = Impl.this.internalParent;
    override <synthetic> def internalCopy$default$3: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad;
    override <synthetic> def internalCopy$default$4: scala.meta.Origin = Impl.this.internalOrigin;
    def parent: Option[scala.meta.Tree] = if (Impl.this.internalParent.!=(null))
      scala.Some.apply[scala.meta.Tree](Impl.this.internalParent)
    else
      scala.None;
    def origin: scala.meta.Origin = Impl.this.internalOrigin;
    def cond: scala.meta.internal.ast.Term = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.cond");
          this._cond_=({
            <artifact> val qual$84: scala.meta.internal.ast.Term = this.internalPrototype.cond;
            <artifact> val x$358: scala.meta.internal.ast.Term = this.internalPrototype.cond;
            <artifact> val x$359: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$360: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$84.internalCopy$default$3;
            <artifact> val x$361: scala.meta.Origin = qual$84.internalCopy$default$4;
            qual$84.internalCopy(x$358, x$359, x$360, x$361)
          })
        }
      else
        (): Unit);
      this._cond
    };
    def thenp: scala.meta.internal.ast.Term = {
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.thenp");
          this._thenp_=({
            <artifact> val qual$85: scala.meta.internal.ast.Term = this.internalPrototype.thenp;
            <artifact> val x$362: scala.meta.internal.ast.Term = this.internalPrototype.thenp;
            <artifact> val x$363: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$364: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$85.internalCopy$default$3;
            <artifact> val x$365: scala.meta.Origin = qual$85.internalCopy$default$4;
            qual$85.internalCopy(x$362, x$363, x$364, x$365)
          })
        }
      else
        (): Unit);
      this._thenp
    };
    def elsep: scala.meta.internal.ast.Term = {
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.elsep");
          this._elsep_=({
            <artifact> val qual$86: scala.meta.internal.ast.Term = this.internalPrototype.elsep;
            <artifact> val x$366: scala.meta.internal.ast.Term = this.internalPrototype.elsep;
            <artifact> val x$367: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$368: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$86.internalCopy$default$3;
            <artifact> val x$369: scala.meta.Origin = qual$86.internalCopy$default$4;
            qual$86.internalCopy(x$366, x$367, x$368, x$369)
          })
        }
      else
        (): Unit);
      this._elsep
    }
  };
  @org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass abstract private[meta] trait Unquote extends AnyRef with scala.meta.internal.ast.Term.If with meta.internal.ast.Quasi.Unquote with scala.meta.internal.ast.Term.Unquote with Product {
    @org.scalameta.ast.internal.astField def tree: Any;
    override type ThisType <: scala.meta.internal.ast.Term.If.Unquote
  };
  @@<?> @@<?> private[meta] object Unquote extends scala.AnyRef {
    def <init>(): scala.meta.internal.ast.Term.If.Unquote.type = {
      Unquote.super.<init>();
      ()
    };
    def internalTag: Int = 145;
    def apply(tree: Any, origin: scala.meta.Origin = scala.meta.Origin.None): scala.meta.internal.ast.Term.If.Unquote = {
      def internal(tree: Any, origin: scala.meta.Origin): scala.meta.internal.ast.Term.If.Unquote = {
        ((): Unit);
        ();
        ();
        val node: scala.meta.internal.ast.Term.If.Unquote.Impl = new Unquote.this.Impl(null, null, scala.collection.immutable.Nil, origin)((tree: Any));
        ((): Unit);
        node
      };
      internal(tree, origin)
    };
    <synthetic> def apply$default$2: scala.meta.Origin = scala.meta.Origin.None;
    @inline final def unapply(x: scala.meta.internal.ast.Term.If.Unquote): Option[Any] = if (x.==(null))
      scala.None
    else
      scala.Some.apply[Any](x.tree);
    import scala.language.experimental.{macros=>prettyPlease};
    import scala.language.implicitConversions;
    @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalameta.ast.internal$Macros", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.internal.ast.Term.If.Unquote, scala.meta.internal.ast.Term.If.Unquote.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.internal.ast.Term.If.Unquote): scala.meta.internal.ast.Term.If.Unquote.Api = new org.scalameta.ast.internal.Macros(null).interfaceToApi[scala.meta.internal.ast.Term.If.Unquote, scala.meta.internal.ast.Term.If.Unquote.Api];
    abstract trait Api extends AnyRef with scala.meta.internal.ast.Term.If.Unquote {
      def /*Api*/$init$(): Unit = {
        ()
      };
      override def cond: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported unquoting position");
      override def thenp: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported unquoting position");
      override def elsep: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported unquoting position");
      def pt: Class[_] = classOf[scala.meta.internal.ast.Term$$If];
      def copy(tree: Any = this.tree, origin: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this)): Api.this.ThisType = If.this.Unquote.apply(tree, origin);
      <synthetic> def copy$default$1: Any = this.tree;
      <synthetic> def copy$default$2: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this);
      override type ThisType = scala.meta.internal.ast.Term.If.Unquote;
      override def internalTag: Int = If.this.Unquote.internalTag;
      override def productPrefix: String = ("Term.If.Unquote": String);
      override def productArity: Int = 1;
      override def productElement(n: Int): Any = n match {
        case 0 => this.tree
        case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
      };
      override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
    };
    final private[Unquote] class Impl extends AnyRef with scala.meta.internal.ast.Term.If.Unquote.Api {
      <paramaccessor> private[this] val internalPrototype: scala.meta.internal.ast.Term.If.Unquote = _;
      <stable> <accessor> <paramaccessor> protected def internalPrototype: scala.meta.internal.ast.Term.If.Unquote = Impl.this.internalPrototype;
      <paramaccessor> private[this] val internalParent: scala.meta.Tree = _;
      <stable> <accessor> <paramaccessor> protected def internalParent: scala.meta.Tree = Impl.this.internalParent;
      <paramaccessor> private[this] val internalScratchpad: scala.collection.immutable.Seq[Any] = _;
      <stable> <accessor> <paramaccessor> protected def internalScratchpad: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad;
      <paramaccessor> private[this] val internalOrigin: scala.meta.Origin = _;
      <stable> <accessor> <paramaccessor> protected def internalOrigin: scala.meta.Origin = Impl.this.internalOrigin;
      <paramaccessor> private[this] var _tree: Any = _;
      <accessor> <paramaccessor> def _tree: Any = Impl.this._tree;
      <accessor> <paramaccessor> def _tree_=(x$1: Any): Unit = Impl.this._tree = x$1;
      def <init>(internalPrototype: scala.meta.internal.ast.Term.If.Unquote, internalParent: scala.meta.Tree, internalScratchpad: scala.collection.immutable.Seq[Any], internalOrigin: scala.meta.Origin)(_tree: Any): scala.meta.internal.ast.Term.If.Unquote.Impl = {
        Impl.super.<init>();
        ()
      };
      private[meta] def internalCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.internalParent, scratchpad: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad, origin: scala.meta.Origin = Impl.this.internalOrigin): Impl.this.ThisType = new Unquote.this.Impl(prototype.asInstanceOf[Impl.this.ThisType], parent, scratchpad, origin)((this._tree: Any));
      override <synthetic> def internalCopy$default$1: scala.meta.Tree = this;
      override <synthetic> def internalCopy$default$2: scala.meta.Tree = Impl.this.internalParent;
      override <synthetic> def internalCopy$default$3: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad;
      override <synthetic> def internalCopy$default$4: scala.meta.Origin = Impl.this.internalOrigin;
      def parent: Option[scala.meta.Tree] = if (Impl.this.internalParent.!=(null))
        scala.Some.apply[scala.meta.Tree](Impl.this.internalParent)
      else
        scala.None;
      def origin: scala.meta.Origin = Impl.this.internalOrigin;
      def tree: Any = {
        ((): Unit);
        this._tree
      }
    }
  };
  @org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass abstract private[meta] trait Ellipsis extends AnyRef with scala.meta.internal.ast.Term.If with meta.internal.ast.Quasi.Ellipsis with scala.meta.internal.ast.Term.Ellipsis with Product {
    @org.scalameta.ast.internal.astField def tree: scala.meta.internal.ast.Tree;
    @org.scalameta.ast.internal.astField def rank: Int;
    override type ThisType <: scala.meta.internal.ast.Term.If.Ellipsis
  };
  @@<?> @@<?> private[meta] object Ellipsis extends scala.AnyRef {
    def <init>(): scala.meta.internal.ast.Term.If.Ellipsis.type = {
      Ellipsis.super.<init>();
      ()
    };
    def internalTag: Int = 146;
    def apply(tree: scala.meta.internal.ast.Tree, rank: Int, origin: scala.meta.Origin = scala.meta.Origin.None): scala.meta.internal.ast.Term.If.Ellipsis = {
      def internal(tree: scala.meta.internal.ast.Tree, rank: Int, origin: scala.meta.Origin): scala.meta.internal.ast.Term.If.Ellipsis = {
        ((): Unit);
        ({
          val result$macro$429: Boolean = tree.!=(null);
          if (result$macro$429)
            scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
          else
            scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("tree is equal to null"))
        } match {
          case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
          case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$428 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("tree.!=(null)", failures$macro$428, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Tree](scala.Tuple2.apply[String, scala.meta.internal.ast.Tree]("tree", tree)))
        }: Unit);
        ();
        ();
        ();
        val node: scala.meta.internal.ast.Term.If.Ellipsis.Impl = new Ellipsis.this.Impl(null, null, scala.collection.immutable.Nil, origin)((null: scala.meta.internal.ast.Tree), (rank: Int));
        (node._tree_=(tree.internalCopy(tree, node, tree.internalCopy$default$3, tree.internalCopy$default$4)): Unit);
        ((): Unit);
        node
      };
      internal(tree, rank, origin)
    };
    <synthetic> def apply$default$3: scala.meta.Origin = scala.meta.Origin.None;
    @inline final def unapply(x: scala.meta.internal.ast.Term.If.Ellipsis): Option[(scala.meta.internal.ast.Tree, Int)] = if (x.==(null))
      scala.None
    else
      scala.Some.apply[(scala.meta.internal.ast.Tree, Int)](scala.Tuple2.apply[scala.meta.internal.ast.Tree, Int](x.tree, x.rank));
    import scala.language.experimental.{macros=>prettyPlease};
    import scala.language.implicitConversions;
    @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalameta.ast.internal$Macros", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.internal.ast.Term.If.Ellipsis, scala.meta.internal.ast.Term.If.Ellipsis.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.internal.ast.Term.If.Ellipsis): scala.meta.internal.ast.Term.If.Ellipsis.Api = new org.scalameta.ast.internal.Macros(null).interfaceToApi[scala.meta.internal.ast.Term.If.Ellipsis, scala.meta.internal.ast.Term.If.Ellipsis.Api];
    abstract trait Api extends AnyRef with scala.meta.internal.ast.Term.If.Ellipsis {
      def /*Api*/$init$(): Unit = {
        ()
      };
      override def cond: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported splicing position");
      override def thenp: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported splicing position");
      override def elsep: Nothing = throw new scala.`package`.UnsupportedOperationException("unsupported splicing position");
      def pt: Class[_] = org.scalameta.runtime.`package`.arrayClass(classOf[scala.meta.internal.ast.Term$$If], Api.this.rank);
      def copy(tree: scala.meta.internal.ast.Tree = this.tree, rank: Int = this.rank, origin: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this)): Api.this.ThisType = If.this.Ellipsis.apply(tree, rank, origin);
      <synthetic> def copy$default$1: scala.meta.internal.ast.Tree = this.tree;
      <synthetic> def copy$default$2: Int = this.rank;
      <synthetic> def copy$default$3: scala.meta.Origin = scala.meta.Origin.Transformed.apply(this);
      override type ThisType = scala.meta.internal.ast.Term.If.Ellipsis;
      override def internalTag: Int = If.this.Ellipsis.internalTag;
      override def productPrefix: String = ("Term.If.Ellipsis": String);
      override def productArity: Int = 2;
      override def productElement(n: Int): Any = n match {
        case 0 => this.tree
        case 1 => this.rank
        case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
      };
      override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
    };
    final private[Ellipsis] class Impl extends AnyRef with scala.meta.internal.ast.Term.If.Ellipsis.Api {
      <paramaccessor> private[this] val internalPrototype: scala.meta.internal.ast.Term.If.Ellipsis = _;
      <stable> <accessor> <paramaccessor> protected def internalPrototype: scala.meta.internal.ast.Term.If.Ellipsis = Impl.this.internalPrototype;
      <paramaccessor> private[this] val internalParent: scala.meta.Tree = _;
      <stable> <accessor> <paramaccessor> protected def internalParent: scala.meta.Tree = Impl.this.internalParent;
      <paramaccessor> private[this] val internalScratchpad: scala.collection.immutable.Seq[Any] = _;
      <stable> <accessor> <paramaccessor> protected def internalScratchpad: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad;
      <paramaccessor> private[this] val internalOrigin: scala.meta.Origin = _;
      <stable> <accessor> <paramaccessor> protected def internalOrigin: scala.meta.Origin = Impl.this.internalOrigin;
      <paramaccessor> private[this] var _tree: scala.meta.internal.ast.Tree = _;
      <accessor> <paramaccessor> def _tree: scala.meta.internal.ast.Tree = Impl.this._tree;
      <accessor> <paramaccessor> def _tree_=(x$1: scala.meta.internal.ast.Tree): Unit = Impl.this._tree = x$1;
      <paramaccessor> private[this] var _rank: Int = _;
      <accessor> <paramaccessor> def _rank: Int = Impl.this._rank;
      <accessor> <paramaccessor> def _rank_=(x$1: Int): Unit = Impl.this._rank = x$1;
      def <init>(internalPrototype: scala.meta.internal.ast.Term.If.Ellipsis, internalParent: scala.meta.Tree, internalScratchpad: scala.collection.immutable.Seq[Any], internalOrigin: scala.meta.Origin)(_tree: scala.meta.internal.ast.Tree, _rank: Int): scala.meta.internal.ast.Term.If.Ellipsis.Impl = {
        Impl.super.<init>();
        ()
      };
      private[meta] def internalCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.internalParent, scratchpad: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad, origin: scala.meta.Origin = Impl.this.internalOrigin): Impl.this.ThisType = new Ellipsis.this.Impl(prototype.asInstanceOf[Impl.this.ThisType], parent, scratchpad, origin)((null: scala.meta.internal.ast.Tree), (this._rank: Int));
      override <synthetic> def internalCopy$default$1: scala.meta.Tree = this;
      override <synthetic> def internalCopy$default$2: scala.meta.Tree = Impl.this.internalParent;
      override <synthetic> def internalCopy$default$3: scala.collection.immutable.Seq[Any] = Impl.this.internalScratchpad;
      override <synthetic> def internalCopy$default$4: scala.meta.Origin = Impl.this.internalOrigin;
      def parent: Option[scala.meta.Tree] = if (Impl.this.internalParent.!=(null))
        scala.Some.apply[scala.meta.Tree](Impl.this.internalParent)
      else
        scala.None;
      def origin: scala.meta.Origin = Impl.this.internalOrigin;
      def tree: scala.meta.internal.ast.Tree = {
        (if (this._tree.==(null))
          {
            scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.tree");
            this._tree_=({
              <artifact> val qual$87: scala.meta.internal.ast.Tree = this.internalPrototype.tree;
              <artifact> val x$370: scala.meta.internal.ast.Tree = this.internalPrototype.tree;
              <artifact> val x$371: scala.meta.internal.ast.Term.If.Ellipsis.Impl = this;
              <artifact> val x$372: scala.collection.immutable.Seq[Any] @scala.reflect.internal.annotations.uncheckedBounds = qual$87.internalCopy$default$3;
              <artifact> val x$373: scala.meta.Origin = qual$87.internalCopy$default$4;
              qual$87.internalCopy(x$370, x$371, x$372, x$373)
            })
          }
        else
          (): Unit);
        this._tree
      };
      def rank: Int = {
        ((): Unit);
        this._rank
      }
    }
  }
};
```
