### Internal structure of scala.meta ASTs

We use macro annotations to generate swaths of boilerplate that make our abstract syntax trees efficient and convenient.
Here's the code that we write in [Trees.scala](/scalameta/trees/src/main/scala/scala/meta/Trees.scala):

```
@ast class If(cond: Term, thenp: Term, elsep: Term) extends Term
```

Here's the code generated by the `@ast` macro annotation:

```
@new _root_.scala.meta.internal.ast.Metadata.astClass() @new _root_.org.scalameta.adt.Metadata.leafClass() abstract trait If extends Term with _root_.scala.Product {
  @new _root_.scala.meta.internal.ast.Metadata.astField() def cond: Term;
  @new _root_.scala.meta.internal.ast.Metadata.astField() def thenp: Term;
  @new _root_.scala.meta.internal.ast.Metadata.astField() def elsep: Term;
  override type ThisType <: If
}
@new _root_.scala.meta.internal.ast.Metadata.astCompanion() @new _root_.org.scalameta.adt.Metadata.leafCompanion() object If extends scala.AnyRef {
  def <init>() = {
    super.<init>();
    ()
  };
  def privateTag: _root_.scala.Int = _root_.org.scalameta.adt.AdtTyperMacros.calculateTag[If];
  def apply(cond: Term, thenp: Term, elsep: Term): If = {
    def internal(cond: Term, thenp: Term, elsep: Term): If = {
      _root_.scala.meta.internal.ast.AstTyperMacros.hierarchyCheck[If];
      _root_.org.scalameta.data.DataTyperMacros.nullCheck(cond);
      _root_.org.scalameta.data.DataTyperMacros.nullCheck(thenp);
      _root_.org.scalameta.data.DataTyperMacros.nullCheck(elsep);
      _root_.org.scalameta.data.DataTyperMacros.emptyCheck(cond);
      _root_.org.scalameta.data.DataTyperMacros.emptyCheck(thenp);
      _root_.org.scalameta.data.DataTyperMacros.emptyCheck(elsep);
      val node = new Impl(_root_.scala.meta.internal.flags.`package`.ZERO, null, null, null, null, null)(_root_.scala.meta.internal.ast.AstTyperMacros.initParam(cond), _root_.scala.meta.internal.ast.AstTyperMacros.initParam(thenp), _root_.scala.meta.internal.ast.AstTyperMacros.initParam(elsep));
      _root_.scala.meta.internal.ast.AstTyperMacros.storeField(node._cond, cond);
      _root_.scala.meta.internal.ast.AstTyperMacros.storeField(node._thenp, thenp);
      _root_.scala.meta.internal.ast.AstTyperMacros.storeField(node._elsep, elsep);
      node
    };
    internal(cond, thenp, elsep)
  };
  @new _root_.scala.inline() final def unapply(x: If): Option[scala.Tuple3[Term, Term, Term]] = if (x.$eq$eq(null))
    _root_.scala.None
  else
    _root_.scala.Some(scala.Tuple3(x.cond, x.thenp, x.elsep));
  import _root_.scala.language.experimental.{macros=>prettyPlease};
  import _root_.scala.language.implicitConversions;
  implicit <macro> def interfaceToApi(interface: If): Api = _root_.scala.meta.internal.ast#AstTyperMacrosBundle.interfaceToApi[If, Api];
  abstract trait Api extends If {
    def $init$() = {
      ()
    };
    def tokens: _root_.scala.meta.tokens.Tokens;
    private[meta] def env: _root_.scala.meta.internal.semantic.Environment;
    private[meta] def typing: _root_.scala.meta.internal.semantic.Typing;
    def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep): If = If.apply(cond, thenp, elsep).withTokens(tokens = _root_.scala.meta.internal.tokens.TransformedTokens(this));
    protected def privateWithFlags(flags: _root_.scala.meta.internal.flags.`package`.Flags): If = {
      if (flags.$amp(_root_.scala.meta.internal.flags.`package`.TYPECHECKED).$eq$eq(_root_.scala.meta.internal.flags.`package`.TYPECHECKED).$amp$amp(this.typing.$eq$eq(_root_.scala.meta.internal.semantic.Typing.Zero)))
        throw new _root_.scala.`package`.UnsupportedOperationException("failed to enable TYPECHECKED for ".$plus(_root_.scala.meta.internal.prettyprinters.Attributes.attributesTree[_root_.scala.meta.Tree](_root_.scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, _root_.scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString))
      else
        ();
      this.privateCopy(flags = flags)
    };
    def withTokens(tokens: _root_.scala.meta.tokens.Tokens): If = this.privateCopy(tokens = tokens);
    def inheritTokens(other: _root_.scala.meta.Tree): If = this.privateCopy(tokens = other.tokens);
    private[meta] def withEnv(env: _root_.scala.meta.internal.semantic.Environment): If = this.privateCopy(flags = this.privateFlags.$amp(_root_.scala.meta.internal.flags.`package`.TYPECHECKED.unary_$tilde), env = env, denot = this.privateDenot, typing = _root_.scala.meta.internal.semantic.Typing.Zero);
    override private[meta] def withAttrs(typingLike: _root_.scala.meta.internal.semantic.TypingLike): If = {
      if (this.isInstanceOf[_root_.scala.meta.Term.Name].$bar$bar(this.isInstanceOf[_root_.scala.meta.Ctor.Name]))
        throw new UnsupportedOperationException("need to simultaneously set both denotation and typing for a ".$plus(this.productPrefix))
      else
        ();
      if (isAttributed)
        throw new UnsupportedOperationException("can only call withAttrs on unattributed or partially attributed trees; if necessary, call .copy() to unattribute and then do .withAttrs(...)".$plus("\n").$plus(_root_.scala.meta.internal.prettyprinters.Attributes.attributesTree[_root_.scala.meta.Tree](_root_.scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, _root_.scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString))
      else
        ();
      val typing = typingLike.typing;
      this.privateCopy(flags = this.privateFlags.$amp(_root_.scala.meta.internal.flags.`package`.TYPECHECKED.unary_$tilde), env = _root_.scala.meta.internal.semantic.Environment.Zero, denot = this.privateDenot, typing = typing)
    };
    override type ThisType = If;
    override def privateTag: _root_.scala.Int = If.privateTag;
    override def productPrefix: _root_.scala.Predef.String = _root_.scala.meta.internal.ast.AstTyperMacros.productPrefix[ThisType];
    override def productArity: _root_.scala.Int = 3;
    override def productElement(n: _root_.scala.Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
    };
    override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this)
  };
  @new _root_.scala.SerialVersionUID(1L) final private[If] class Impl extends Api {
    <paramaccessor> protected val privateFlags: _root_.scala.meta.internal.flags.`package`.Flags = _;
    @new _root_.scala.transient() <paramaccessor> protected val privatePrototype: If = _;
    <paramaccessor> protected val privateParent: _root_.scala.meta.Tree = _;
    @new _root_.scala.transient() <paramaccessor> protected var privateTokens: _root_.scala.meta.tokens.Tokens = _;
    <paramaccessor> protected val privateEnv: _root_.scala.meta.internal.semantic.Environment = _;
    <paramaccessor> protected val privateTyping: _root_.scala.meta.internal.semantic.Typing = _;
    <paramaccessor> var _cond: Term = _;
    <paramaccessor> var _thenp: Term = _;
    <paramaccessor> var _elsep: Term = _;
    def <init>(privateFlags: _root_.scala.meta.internal.flags.`package`.Flags, @new _root_.scala.transient() privatePrototype: If, privateParent: _root_.scala.meta.Tree, @new _root_.scala.transient() privateTokens: _root_.scala.meta.tokens.Tokens, privateEnv: _root_.scala.meta.internal.semantic.Environment, privateTyping: _root_.scala.meta.internal.semantic.Typing)(_cond: Term, _thenp: Term, _elsep: Term) = {
      super.<init>();
      ()
    };
    def parent: _root_.scala.Option[_root_.scala.meta.Tree] = if (privateParent.$bang$eq(null))
      _root_.scala.Some(privateParent)
    else
      _root_.scala.None;
    def children: Seq[_root_.scala.meta.Tree] = _root_.scala.meta.internal.ast.AstTyperMacros.children[ThisType, _root_.scala.meta.Tree];
    def tokens: _root_.scala.meta.tokens.Tokens = {
      privateTokens = privateTokens match {
        case null => _root_.scala.meta.internal.prettyprinters.inferTokens(this, None)
        case _root_.scala.meta.internal.tokens.TransformedTokens((proto @ _)) => _root_.scala.meta.internal.prettyprinters.inferTokens(this, Some(proto))
        case (other @ _) => other
      };
      privateTokens
    };
    private[meta] def env: _root_.scala.meta.internal.semantic.Environment = if (privateEnv.$bang$eq(null))
      privateEnv
    else
      _root_.scala.meta.internal.semantic.Environment.Zero;
    protected def privateDenot: _root_.scala.meta.internal.semantic.Denotation = null;
    private[meta] def typing: _root_.scala.meta.internal.semantic.Typing = if (privateTyping.$bang$eq(null))
      privateTyping
    else
      _root_.scala.meta.internal.semantic.Typing.Zero;
    protected def privateFfi: _root_.scala.meta.internal.ffi.Ffi = null;
    def cond: Term = {
      _root_.scala.meta.internal.ast.AstTyperMacros.loadField(this._cond);
      this._cond
    };
    def thenp: Term = {
      _root_.scala.meta.internal.ast.AstTyperMacros.loadField(this._thenp);
      this._thenp
    };
    def elsep: Term = {
      _root_.scala.meta.internal.ast.AstTyperMacros.loadField(this._elsep);
      this._elsep
    };
    private[meta] def privateCopy(flags: _root_.scala.meta.internal.flags.`package`.Flags = privateFlags, prototype: _root_.scala.meta.Tree = this, parent: _root_.scala.meta.Tree = privateParent, tokens: _root_.scala.meta.tokens.Tokens = privateTokens, env: _root_.scala.meta.internal.semantic.Environment = privateEnv, denot: _root_.scala.meta.internal.semantic.Denotation = privateDenot, typing: _root_.scala.meta.internal.semantic.Typing = privateTyping, ffi: _root_.scala.meta.internal.ffi.Ffi = privateFfi): ThisType = new Impl(flags, prototype.asInstanceOf[ThisType], parent, tokens, env, typing)(_root_.scala.meta.internal.ast.AstTyperMacros.initField(this._cond), _root_.scala.meta.internal.ast.AstTyperMacros.initField(this._thenp), _root_.scala.meta.internal.ast.AstTyperMacros.initField(this._elsep));
    protected def writeReplace(): _root_.scala.AnyRef = {
      _root_.scala.meta.internal.ast.AstTyperMacros.loadField(this._cond);
      _root_.scala.meta.internal.ast.AstTyperMacros.loadField(this._thenp);
      _root_.scala.meta.internal.ast.AstTyperMacros.loadField(this._elsep);
      this
    }
  };
  @new _root_.scala.meta.internal.ast.ast() private[meta] class Quasi extends If with _root_.scala.meta.internal.ast.Quasi with Term.Quasi {
    <paramaccessor> private[this] val rank: _root_.scala.Int = _;
    <paramaccessor> private[this] val tree: _root_.scala.Any = _;
    def <init>(rank: _root_.scala.Int, tree: _root_.scala.Any) = {
      super.<init>();
      ()
    };
    override private[meta] def env: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override protected def privateEnv: _root_.scala.meta.internal.semantic.Environment = null;
    override protected def privateDenot: _root_.scala.meta.internal.semantic.Denotation = null;
    override private[meta] def typing: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override protected def privateTyping: _root_.scala.meta.internal.semantic.Typing = null;
    override protected def privateFfi: _root_.scala.meta.internal.ffi.Ffi = null;
    override def cond: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override def thenp: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override def elsep: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override private[meta] def withEnv(env: _root_.scala.meta.internal.semantic.Environment): _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override private[meta] def withAttrs(typingLike: _root_.scala.meta.internal.semantic.TypingLike): _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def pt: _root_.java.lang.Class[_$53] forSome {
      <synthetic> type _$53
    } = _root_.scala.meta.internal.ast.Helpers.arrayClass(_root_.scala.Predef.classOf[If], this.rank)
  }
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@meta.internal.ast.Metadata.astClass @org.scalameta.adt.Metadata.leafClass abstract trait If extends AnyRef with scala.meta.Term with Product {
  @meta.internal.ast.Metadata.astField def cond: scala.meta.Term;
  @meta.internal.ast.Metadata.astField def thenp: scala.meta.Term;
  @meta.internal.ast.Metadata.astField def elsep: scala.meta.Term;
  override type ThisType <: scala.meta.Term.If
};
@@<?> @@<?> object If extends scala.AnyRef with Serializable {
  def <init>(): scala.meta.Term.If.type = {
    If.super.<init>();
    ()
  };
  def privateTag: Int = 46;
  def apply(cond: scala.meta.Term, thenp: scala.meta.Term, elsep: scala.meta.Term): scala.meta.Term.If = {
    def internal(cond: scala.meta.Term, thenp: scala.meta.Term, elsep: scala.meta.Term): scala.meta.Term.If = {
      ((): Unit);
      (({
        val result$macro$190: Boolean = cond.!=(null);
        if (result$macro$190)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("cond is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$189 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("cond.!=(null)", failures$macro$189, scala.collection.immutable.Map.apply[String, scala.meta.Term](scala.Tuple2.apply[String, scala.meta.Term]("cond", cond)))
      }: Unit): Unit);
      (({
        val result$macro$192: Boolean = thenp.!=(null);
        if (result$macro$192)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("thenp is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$191 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("thenp.!=(null)", failures$macro$191, scala.collection.immutable.Map.apply[String, scala.meta.Term](scala.Tuple2.apply[String, scala.meta.Term]("thenp", thenp)))
      }: Unit): Unit);
      (({
        val result$macro$194: Boolean = elsep.!=(null);
        if (result$macro$194)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("elsep is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$193 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("elsep.!=(null)", failures$macro$193, scala.collection.immutable.Map.apply[String, scala.meta.Term](scala.Tuple2.apply[String, scala.meta.Term]("elsep", elsep)))
      }: Unit): Unit);
      ((): Unit);
      ((): Unit);
      ((): Unit);
      val node: scala.meta.Term.If.Impl = new If.this.Impl(scala.meta.internal.flags.`package`.ZERO, null, null, null, null, null)((null: scala.meta.Term), (null: scala.meta.Term), (null: scala.meta.Term));
      (node._cond_=({
        <artifact> val x$1819: scala.meta.Term = cond;
        <artifact> val x$1820: scala.meta.Term.If.Impl = node;
        <artifact> val x$1821: meta.internal.flags.Flags = cond.privateCopy$default$1;
        <artifact> val x$1822: scala.meta.tokens.Tokens = cond.privateCopy$default$4;
        <artifact> val x$1823: scala.meta.internal.semantic.Environment = cond.privateCopy$default$5;
        <artifact> val x$1824: scala.meta.internal.semantic.Denotation = cond.privateCopy$default$6;
        <artifact> val x$1825: scala.meta.internal.semantic.Typing = cond.privateCopy$default$7;
        <artifact> val x$1826: scala.meta.internal.ffi.Ffi = cond.privateCopy$default$8;
        cond.privateCopy(x$1821, x$1819, x$1820, x$1822, x$1823, x$1824, x$1825, x$1826)
      }): Unit);
      (node._thenp_=({
        <artifact> val x$1827: scala.meta.Term = thenp;
        <artifact> val x$1828: scala.meta.Term.If.Impl = node;
        <artifact> val x$1829: meta.internal.flags.Flags = thenp.privateCopy$default$1;
        <artifact> val x$1830: scala.meta.tokens.Tokens = thenp.privateCopy$default$4;
        <artifact> val x$1831: scala.meta.internal.semantic.Environment = thenp.privateCopy$default$5;
        <artifact> val x$1832: scala.meta.internal.semantic.Denotation = thenp.privateCopy$default$6;
        <artifact> val x$1833: scala.meta.internal.semantic.Typing = thenp.privateCopy$default$7;
        <artifact> val x$1834: scala.meta.internal.ffi.Ffi = thenp.privateCopy$default$8;
        thenp.privateCopy(x$1829, x$1827, x$1828, x$1830, x$1831, x$1832, x$1833, x$1834)
      }): Unit);
      (node._elsep_=({
        <artifact> val x$1835: scala.meta.Term = elsep;
        <artifact> val x$1836: scala.meta.Term.If.Impl = node;
        <artifact> val x$1837: meta.internal.flags.Flags = elsep.privateCopy$default$1;
        <artifact> val x$1838: scala.meta.tokens.Tokens = elsep.privateCopy$default$4;
        <artifact> val x$1839: scala.meta.internal.semantic.Environment = elsep.privateCopy$default$5;
        <artifact> val x$1840: scala.meta.internal.semantic.Denotation = elsep.privateCopy$default$6;
        <artifact> val x$1841: scala.meta.internal.semantic.Typing = elsep.privateCopy$default$7;
        <artifact> val x$1842: scala.meta.internal.ffi.Ffi = elsep.privateCopy$default$8;
        elsep.privateCopy(x$1837, x$1835, x$1836, x$1838, x$1839, x$1840, x$1841, x$1842)
      }): Unit);
      node
    };
    internal(cond, thenp, elsep)
  };
  @inline final def unapply(x: scala.meta.Term.If): Option[(scala.meta.Term, scala.meta.Term, scala.meta.Term)] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[(scala.meta.Term, scala.meta.Term, scala.meta.Term)](scala.Tuple3.apply[scala.meta.Term, scala.meta.Term, scala.meta.Term](x.cond, x.thenp, x.elsep));
  import scala.language.experimental.{macros=>prettyPlease};
  import scala.language.implicitConversions;
  @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "scala.meta.internal.ast.AstTyperMacrosBundle", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.Term.If, scala.meta.Term.If.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.Term.If): scala.meta.Term.If.Api = new scala.meta.internal.ast.AstTyperMacrosBundle(null).interfaceToApi[scala.meta.Term.If, scala.meta.Term.If.Api];
  abstract trait Api extends AnyRef with scala.meta.Term.If {
    def /*Api*/$init$(): Unit = {
      ()
    };
    def tokens: scala.meta.tokens.Tokens;
    private[meta] def env: scala.meta.internal.semantic.Environment;
    private[meta] def typing: scala.meta.internal.semantic.Typing;
    def copy(cond: scala.meta.Term = this.cond, thenp: scala.meta.Term = this.thenp, elsep: scala.meta.Term = this.elsep): scala.meta.Term.If = Term.this.If.apply(cond, thenp, elsep).withTokens(scala.meta.internal.tokens.TransformedTokens.apply(this));
    <synthetic> def copy$default$1: scala.meta.Term = this.cond;
    <synthetic> def copy$default$2: scala.meta.Term = this.thenp;
    <synthetic> def copy$default$3: scala.meta.Term = this.elsep;
    protected def privateWithFlags(flags: meta.internal.flags.Flags): scala.meta.Term.If = {
      if (flags.&(scala.meta.internal.flags.`package`.TYPECHECKED).==(scala.meta.internal.flags.`package`.TYPECHECKED).&&(this.typing.==(scala.meta.internal.semantic.Typing.Zero)))
        throw new scala.`package`.UnsupportedOperationException("failed to enable TYPECHECKED for ".+(scala.meta.internal.prettyprinters.Attributes.attributesTree[scala.meta.Tree](scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString()))
      else
        ();
      this.privateCopy(flags, this.privateCopy$default$2, this.privateCopy$default$3, this.privateCopy$default$4, this.privateCopy$default$5, this.privateCopy$default$6, this.privateCopy$default$7, this.privateCopy$default$8)
    };
    def withTokens(tokens: scala.meta.tokens.Tokens): scala.meta.Term.If = {
      <artifact> val x$1843: scala.meta.tokens.Tokens = tokens;
      <artifact> val x$1844: meta.internal.flags.Flags = this.privateCopy$default$1;
      <artifact> val x$1845: scala.meta.Tree = this.privateCopy$default$2;
      <artifact> val x$1846: scala.meta.Tree = this.privateCopy$default$3;
      <artifact> val x$1847: scala.meta.internal.semantic.Environment = this.privateCopy$default$5;
      <artifact> val x$1848: scala.meta.internal.semantic.Denotation = this.privateCopy$default$6;
      <artifact> val x$1849: scala.meta.internal.semantic.Typing = this.privateCopy$default$7;
      <artifact> val x$1850: scala.meta.internal.ffi.Ffi = this.privateCopy$default$8;
      this.privateCopy(x$1844, x$1845, x$1846, x$1843, x$1847, x$1848, x$1849, x$1850)
    };
    def inheritTokens(other: scala.meta.Tree): scala.meta.Term.If = {
      <artifact> val x$1851: scala.meta.tokens.Tokens = other.tokens;
      <artifact> val x$1852: meta.internal.flags.Flags = this.privateCopy$default$1;
      <artifact> val x$1853: scala.meta.Tree = this.privateCopy$default$2;
      <artifact> val x$1854: scala.meta.Tree = this.privateCopy$default$3;
      <artifact> val x$1855: scala.meta.internal.semantic.Environment = this.privateCopy$default$5;
      <artifact> val x$1856: scala.meta.internal.semantic.Denotation = this.privateCopy$default$6;
      <artifact> val x$1857: scala.meta.internal.semantic.Typing = this.privateCopy$default$7;
      <artifact> val x$1858: scala.meta.internal.ffi.Ffi = this.privateCopy$default$8;
      this.privateCopy(x$1852, x$1853, x$1854, x$1851, x$1855, x$1856, x$1857, x$1858)
    };
    private[meta] def withEnv(env: scala.meta.internal.semantic.Environment): scala.meta.Term.If = {
      <artifact> val x$1859: Int = this.privateFlags.&(scala.meta.internal.flags.`package`.TYPECHECKED.unary_~);
      <artifact> val x$1860: scala.meta.internal.semantic.Environment = env;
      <artifact> val x$1861: scala.meta.internal.semantic.Denotation = this.privateDenot;
      <artifact> val x$1862: meta.internal.semantic.Typing.Zero.type = scala.meta.internal.semantic.Typing.Zero;
      <artifact> val x$1863: scala.meta.Tree = this.privateCopy$default$2;
      <artifact> val x$1864: scala.meta.Tree = this.privateCopy$default$3;
      <artifact> val x$1865: scala.meta.tokens.Tokens = this.privateCopy$default$4;
      <artifact> val x$1866: scala.meta.internal.ffi.Ffi = this.privateCopy$default$8;
      this.privateCopy(x$1859, x$1863, x$1864, x$1865, x$1860, x$1861, x$1862, x$1866)
    };
    override private[meta] def withAttrs(typingLike: meta.internal.semantic.TypingLike): scala.meta.Term.If = {
      if (this.isInstanceOf[meta.Term.Name].||(this.isInstanceOf[meta.Ctor.Name]))
        throw new scala.`package`.UnsupportedOperationException("need to simultaneously set both denotation and typing for a ".+(this.productPrefix))
      else
        ();
      if (Api.this.isAttributed)
        throw new scala.`package`.UnsupportedOperationException("can only call withAttrs on unattributed or partially attributed trees; if necessary, call .copy() to unattribute and then do .withAttrs(...)\n".+(scala.meta.internal.prettyprinters.Attributes.attributesTree[scala.meta.Tree](scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString()))
      else
        ();
      val typing: scala.meta.internal.semantic.Typing = typingLike.typing;
      {
        <artifact> val x$1867: Int = this.privateFlags.&(scala.meta.internal.flags.`package`.TYPECHECKED.unary_~);
        <artifact> val x$1868: meta.internal.semantic.Environment.Zero.type = scala.meta.internal.semantic.Environment.Zero;
        <artifact> val x$1869: scala.meta.internal.semantic.Denotation = this.privateDenot;
        <artifact> val x$1870: scala.meta.internal.semantic.Typing = typing;
        <artifact> val x$1871: scala.meta.Tree = this.privateCopy$default$2;
        <artifact> val x$1872: scala.meta.Tree = this.privateCopy$default$3;
        <artifact> val x$1873: scala.meta.tokens.Tokens = this.privateCopy$default$4;
        <artifact> val x$1874: scala.meta.internal.ffi.Ffi = this.privateCopy$default$8;
        this.privateCopy(x$1867, x$1871, x$1872, x$1873, x$1868, x$1869, x$1870, x$1874)
      }
    };
    override type ThisType = scala.meta.Term.If;
    override def privateTag: Int = Term.this.If.privateTag;
    override def productPrefix: String = ("Term.If": String);
    override def productArity: Int = 3;
    override def productElement(n: Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
    };
    override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
  };
  @SerialVersionUID(value = 1L) final private[If] class Impl extends AnyRef with scala.meta.Term.If.Api {
    <paramaccessor> private[this] val privateFlags: meta.internal.flags.Flags = _;
    <stable> <accessor> <paramaccessor> protected def privateFlags: meta.internal.flags.Flags = Impl.this.privateFlags;
    @transient <paramaccessor> private[this] val privatePrototype: scala.meta.Term.If = _;
    <stable> <accessor> <paramaccessor> protected def privatePrototype: scala.meta.Term.If = Impl.this.privatePrototype;
    <paramaccessor> private[this] val privateParent: scala.meta.Tree = _;
    <stable> <accessor> <paramaccessor> protected def privateParent: scala.meta.Tree = Impl.this.privateParent;
    @transient <paramaccessor> private[this] var privateTokens: scala.meta.tokens.Tokens = _;
    <accessor> <paramaccessor> protected def privateTokens: scala.meta.tokens.Tokens = Impl.this.privateTokens;
    <accessor> <paramaccessor> protected def privateTokens_=(x$1: scala.meta.tokens.Tokens): Unit = Impl.this.privateTokens = x$1;
    <paramaccessor> private[this] val privateEnv: scala.meta.internal.semantic.Environment = _;
    <stable> <accessor> <paramaccessor> protected def privateEnv: scala.meta.internal.semantic.Environment = Impl.this.privateEnv;
    <paramaccessor> private[this] val privateTyping: scala.meta.internal.semantic.Typing = _;
    <stable> <accessor> <paramaccessor> protected def privateTyping: scala.meta.internal.semantic.Typing = Impl.this.privateTyping;
    <paramaccessor> private[this] var _cond: scala.meta.Term = _;
    <accessor> <paramaccessor> def _cond: scala.meta.Term = Impl.this._cond;
    <accessor> <paramaccessor> def _cond_=(x$1: scala.meta.Term): Unit = Impl.this._cond = x$1;
    <paramaccessor> private[this] var _thenp: scala.meta.Term = _;
    <accessor> <paramaccessor> def _thenp: scala.meta.Term = Impl.this._thenp;
    <accessor> <paramaccessor> def _thenp_=(x$1: scala.meta.Term): Unit = Impl.this._thenp = x$1;
    <paramaccessor> private[this] var _elsep: scala.meta.Term = _;
    <accessor> <paramaccessor> def _elsep: scala.meta.Term = Impl.this._elsep;
    <accessor> <paramaccessor> def _elsep_=(x$1: scala.meta.Term): Unit = Impl.this._elsep = x$1;
    def <init>(privateFlags: meta.internal.flags.Flags, privatePrototype: scala.meta.Term.If, privateParent: scala.meta.Tree, privateTokens: scala.meta.tokens.Tokens, privateEnv: scala.meta.internal.semantic.Environment, privateTyping: scala.meta.internal.semantic.Typing)(_cond: scala.meta.Term, _thenp: scala.meta.Term, _elsep: scala.meta.Term): scala.meta.Term.If.Impl = {
      Impl.super.<init>();
      ()
    };
    def parent: Option[scala.meta.Tree] = if (Impl.this.privateParent.!=(null))
      scala.Some.apply[scala.meta.Tree](Impl.this.privateParent)
    else
      scala.None;
    def children: scala.collection.immutable.Seq[scala.meta.Tree] = (scala.collection.immutable.List.apply[scala.meta.Term](this.cond, this.thenp, this.elsep): scala.collection.immutable.Seq[scala.meta.Tree]);
    def tokens: scala.meta.tokens.Tokens = {
      Impl.this.privateTokens_=(Impl.this.privateTokens match {
        case null => scala.meta.internal.prettyprinters.inferTokens.apply(this, scala.None)
        case (prototype: scala.meta.Tree)scala.meta.internal.tokens.TransformedTokens((proto @ _)) => scala.meta.internal.prettyprinters.inferTokens.apply(this, scala.Some.apply[scala.meta.Tree](proto))
        case (other @ _) => other
      });
      Impl.this.privateTokens
    };
    private[meta] def env: scala.meta.internal.semantic.Environment = if (Impl.this.privateEnv.!=(null))
      Impl.this.privateEnv
    else
      scala.meta.internal.semantic.Environment.Zero;
    protected def privateDenot: scala.meta.internal.semantic.Denotation = null;
    private[meta] def typing: scala.meta.internal.semantic.Typing = if (Impl.this.privateTyping.!=(null))
      Impl.this.privateTyping
    else
      scala.meta.internal.semantic.Typing.Zero;
    protected def privateFfi: scala.meta.internal.ffi.Ffi = null;
    def cond: scala.meta.Term = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.cond");
          this._cond_=({
            val copyCond$macro$195: scala.meta.Term#ThisType = {
              <artifact> val qual$43: scala.meta.Term = this.privatePrototype.cond;
              <artifact> val x$1875: scala.meta.Term = this.privatePrototype.cond;
              <artifact> val x$1876: scala.meta.Term.If.Impl = this;
              <artifact> val x$1877: meta.internal.flags.Flags = qual$43.privateCopy$default$1;
              <artifact> val x$1878: scala.meta.tokens.Tokens = qual$43.privateCopy$default$4;
              <artifact> val x$1879: scala.meta.internal.semantic.Environment = qual$43.privateCopy$default$5;
              <artifact> val x$1880: scala.meta.internal.semantic.Denotation = qual$43.privateCopy$default$6;
              <artifact> val x$1881: scala.meta.internal.semantic.Typing = qual$43.privateCopy$default$7;
              <artifact> val x$1882: scala.meta.internal.ffi.Ffi = qual$43.privateCopy$default$8;
              qual$43.privateCopy(x$1877, x$1875, x$1876, x$1878, x$1879, x$1880, x$1881, x$1882)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term#ThisType](copyCond$macro$195).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked)
            else
              copyCond$macro$195
          })
        }
      else
        (): Unit);
      this._cond
    };
    def thenp: scala.meta.Term = {
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.thenp");
          this._thenp_=({
            val copyThenp$macro$196: scala.meta.Term#ThisType = {
              <artifact> val qual$44: scala.meta.Term = this.privatePrototype.thenp;
              <artifact> val x$1883: scala.meta.Term = this.privatePrototype.thenp;
              <artifact> val x$1884: scala.meta.Term.If.Impl = this;
              <artifact> val x$1885: meta.internal.flags.Flags = qual$44.privateCopy$default$1;
              <artifact> val x$1886: scala.meta.tokens.Tokens = qual$44.privateCopy$default$4;
              <artifact> val x$1887: scala.meta.internal.semantic.Environment = qual$44.privateCopy$default$5;
              <artifact> val x$1888: scala.meta.internal.semantic.Denotation = qual$44.privateCopy$default$6;
              <artifact> val x$1889: scala.meta.internal.semantic.Typing = qual$44.privateCopy$default$7;
              <artifact> val x$1890: scala.meta.internal.ffi.Ffi = qual$44.privateCopy$default$8;
              qual$44.privateCopy(x$1885, x$1883, x$1884, x$1886, x$1887, x$1888, x$1889, x$1890)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term#ThisType](copyThenp$macro$196).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked)
            else
              copyThenp$macro$196
          })
        }
      else
        (): Unit);
      this._thenp
    };
    def elsep: scala.meta.Term = {
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.elsep");
          this._elsep_=({
            val copyElsep$macro$197: scala.meta.Term#ThisType = {
              <artifact> val qual$45: scala.meta.Term = this.privatePrototype.elsep;
              <artifact> val x$1891: scala.meta.Term = this.privatePrototype.elsep;
              <artifact> val x$1892: scala.meta.Term.If.Impl = this;
              <artifact> val x$1893: meta.internal.flags.Flags = qual$45.privateCopy$default$1;
              <artifact> val x$1894: scala.meta.tokens.Tokens = qual$45.privateCopy$default$4;
              <artifact> val x$1895: scala.meta.internal.semantic.Environment = qual$45.privateCopy$default$5;
              <artifact> val x$1896: scala.meta.internal.semantic.Denotation = qual$45.privateCopy$default$6;
              <artifact> val x$1897: scala.meta.internal.semantic.Typing = qual$45.privateCopy$default$7;
              <artifact> val x$1898: scala.meta.internal.ffi.Ffi = qual$45.privateCopy$default$8;
              qual$45.privateCopy(x$1893, x$1891, x$1892, x$1894, x$1895, x$1896, x$1897, x$1898)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term#ThisType](copyElsep$macro$197).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked)
            else
              copyElsep$macro$197
          })
        }
      else
        (): Unit);
      this._elsep
    };
    private[meta] def privateCopy(flags: meta.internal.flags.Flags = Impl.this.privateFlags, prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.privateParent, tokens: scala.meta.tokens.Tokens = Impl.this.privateTokens, env: scala.meta.internal.semantic.Environment = Impl.this.privateEnv, denot: scala.meta.internal.semantic.Denotation = Impl.this.privateDenot, typing: scala.meta.internal.semantic.Typing = Impl.this.privateTyping, ffi: scala.meta.internal.ffi.Ffi = Impl.this.privateFfi): Impl.this.ThisType = new If.this.Impl(flags, prototype.asInstanceOf[Impl.this.ThisType], parent, tokens, env, typing)((null: scala.meta.Term), (null: scala.meta.Term), (null: scala.meta.Term));
    override <synthetic> def privateCopy$default$1: meta.internal.flags.Flags = Impl.this.privateFlags;
    override <synthetic> def privateCopy$default$2: scala.meta.Tree = this;
    override <synthetic> def privateCopy$default$3: scala.meta.Tree = Impl.this.privateParent;
    override <synthetic> def privateCopy$default$4: scala.meta.tokens.Tokens = Impl.this.privateTokens;
    override <synthetic> def privateCopy$default$5: scala.meta.internal.semantic.Environment = Impl.this.privateEnv;
    override <synthetic> def privateCopy$default$6: scala.meta.internal.semantic.Denotation = Impl.this.privateDenot;
    override <synthetic> def privateCopy$default$7: scala.meta.internal.semantic.Typing = Impl.this.privateTyping;
    override <synthetic> def privateCopy$default$8: scala.meta.internal.ffi.Ffi = Impl.this.privateFfi;
    protected def writeReplace(): AnyRef = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.cond");
          this._cond_=({
            val copyCond$macro$198: scala.meta.Term#ThisType = {
              <artifact> val qual$46: scala.meta.Term = this.privatePrototype.cond;
              <artifact> val x$1899: scala.meta.Term = this.privatePrototype.cond;
              <artifact> val x$1900: scala.meta.Term.If.Impl = this;
              <artifact> val x$1901: meta.internal.flags.Flags = qual$46.privateCopy$default$1;
              <artifact> val x$1902: scala.meta.tokens.Tokens = qual$46.privateCopy$default$4;
              <artifact> val x$1903: scala.meta.internal.semantic.Environment = qual$46.privateCopy$default$5;
              <artifact> val x$1904: scala.meta.internal.semantic.Denotation = qual$46.privateCopy$default$6;
              <artifact> val x$1905: scala.meta.internal.semantic.Typing = qual$46.privateCopy$default$7;
              <artifact> val x$1906: scala.meta.internal.ffi.Ffi = qual$46.privateCopy$default$8;
              qual$46.privateCopy(x$1901, x$1899, x$1900, x$1902, x$1903, x$1904, x$1905, x$1906)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term#ThisType](copyCond$macro$198).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked)
            else
              copyCond$macro$198
          })
        }
      else
        (): Unit);
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.thenp");
          this._thenp_=({
            val copyThenp$macro$199: scala.meta.Term#ThisType = {
              <artifact> val qual$47: scala.meta.Term = this.privatePrototype.thenp;
              <artifact> val x$1907: scala.meta.Term = this.privatePrototype.thenp;
              <artifact> val x$1908: scala.meta.Term.If.Impl = this;
              <artifact> val x$1909: meta.internal.flags.Flags = qual$47.privateCopy$default$1;
              <artifact> val x$1910: scala.meta.tokens.Tokens = qual$47.privateCopy$default$4;
              <artifact> val x$1911: scala.meta.internal.semantic.Environment = qual$47.privateCopy$default$5;
              <artifact> val x$1912: scala.meta.internal.semantic.Denotation = qual$47.privateCopy$default$6;
              <artifact> val x$1913: scala.meta.internal.semantic.Typing = qual$47.privateCopy$default$7;
              <artifact> val x$1914: scala.meta.internal.ffi.Ffi = qual$47.privateCopy$default$8;
              qual$47.privateCopy(x$1909, x$1907, x$1908, x$1910, x$1911, x$1912, x$1913, x$1914)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term#ThisType](copyThenp$macro$199).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked)
            else
              copyThenp$macro$199
          })
        }
      else
        (): Unit);
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.elsep");
          this._elsep_=({
            val copyElsep$macro$200: scala.meta.Term#ThisType = {
              <artifact> val qual$48: scala.meta.Term = this.privatePrototype.elsep;
              <artifact> val x$1915: scala.meta.Term = this.privatePrototype.elsep;
              <artifact> val x$1916: scala.meta.Term.If.Impl = this;
              <artifact> val x$1917: meta.internal.flags.Flags = qual$48.privateCopy$default$1;
              <artifact> val x$1918: scala.meta.tokens.Tokens = qual$48.privateCopy$default$4;
              <artifact> val x$1919: scala.meta.internal.semantic.Environment = qual$48.privateCopy$default$5;
              <artifact> val x$1920: scala.meta.internal.semantic.Denotation = qual$48.privateCopy$default$6;
              <artifact> val x$1921: scala.meta.internal.semantic.Typing = qual$48.privateCopy$default$7;
              <artifact> val x$1922: scala.meta.internal.ffi.Ffi = qual$48.privateCopy$default$8;
              qual$48.privateCopy(x$1917, x$1915, x$1916, x$1918, x$1919, x$1920, x$1921, x$1922)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term#ThisType](copyElsep$macro$200).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.Term.If.Impl](this).isTypechecked)
            else
              copyElsep$macro$200
          })
        }
      else
        (): Unit);
      this
    }
  };
  @meta.internal.ast.Metadata.astClass @org.scalameta.adt.Metadata.leafClass abstract private[meta] trait Quasi extends AnyRef with scala.meta.Term.If with scala.meta.internal.ast.Quasi with scala.meta.Term.Quasi with Product {
    @meta.internal.ast.Metadata.astField def rank: Int;
    @meta.internal.ast.Metadata.astField def tree: Any;
    override type ThisType <: scala.meta.Term.If.Quasi
  };
  @@<?> @@<?> private[meta] object Quasi extends scala.AnyRef with Serializable {
    def <init>(): scala.meta.Term.If.Quasi.type = {
      Quasi.super.<init>();
      ()
    };
    def privateTag: Int = 47;
    def apply(rank: Int, tree: Any): scala.meta.Term.If.Quasi = {
      def internal(rank: Int, tree: Any): scala.meta.Term.If.Quasi = {
        ((): Unit);
        ((): Unit);
        ((): Unit);
        ((): Unit);
        ((): Unit);
        val node: scala.meta.Term.If.Quasi.Impl = new Quasi.this.Impl(scala.meta.internal.flags.`package`.ZERO, null, null, null)((rank: Int), (tree: Any));
        ((): Unit);
        ((): Unit);
        node
      };
      internal(rank, tree)
    };
    @inline final def unapply(x: scala.meta.Term.If.Quasi): Option[(Int, Any)] = if (x.==(null))
      scala.None
    else
      scala.Some.apply[(Int, Any)](scala.Tuple2.apply[Int, Any](x.rank, x.tree));
    import scala.language.experimental.{macros=>prettyPlease};
    import scala.language.implicitConversions;
    @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "scala.meta.internal.ast.AstTyperMacrosBundle", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.Term.If.Quasi, scala.meta.Term.If.Quasi.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.Term.If.Quasi): scala.meta.Term.If.Quasi.Api = new scala.meta.internal.ast.AstTyperMacrosBundle(null).interfaceToApi[scala.meta.Term.If.Quasi, scala.meta.Term.If.Quasi.Api];
    abstract trait Api extends AnyRef with scala.meta.Term.If.Quasi {
      def /*Api*/$init$(): Unit = {
        ()
      };
      override private[meta] def env: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override protected def privateEnv: scala.meta.internal.semantic.Environment = null;
      override protected def privateDenot: scala.meta.internal.semantic.Denotation = null;
      override private[meta] def typing: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override protected def privateTyping: scala.meta.internal.semantic.Typing = null;
      override protected def privateFfi: scala.meta.internal.ffi.Ffi = null;
      override def cond: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override def thenp: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override def elsep: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override private[meta] def withEnv(env: scala.meta.internal.semantic.Environment): Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override private[meta] def withAttrs(typingLike: meta.internal.semantic.TypingLike): Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def pt: Class[_] = scala.meta.internal.ast.Helpers.arrayClass(classOf[scala.meta.Term$$If], this.rank);
      def tokens: scala.meta.tokens.Tokens;
      def copy(rank: Int = this.rank, tree: Any = this.tree): scala.meta.Term.If.Quasi = If.this.Quasi.apply(rank, tree).withTokens(scala.meta.internal.tokens.TransformedTokens.apply(this));
      <synthetic> def copy$default$1: Int = this.rank;
      <synthetic> def copy$default$2: Any = this.tree;
      protected def privateWithFlags(flags: meta.internal.flags.Flags): scala.meta.Term.If.Quasi = {
        this.privateCopy(flags, this.privateCopy$default$2, this.privateCopy$default$3, this.privateCopy$default$4, this.privateCopy$default$5, this.privateCopy$default$6, this.privateCopy$default$7, this.privateCopy$default$8)
      };
      def withTokens(tokens: scala.meta.tokens.Tokens): scala.meta.Term.If.Quasi = {
        <artifact> val x$1923: scala.meta.tokens.Tokens = tokens;
        <artifact> val x$1924: meta.internal.flags.Flags = this.privateCopy$default$1;
        <artifact> val x$1925: scala.meta.Tree = this.privateCopy$default$2;
        <artifact> val x$1926: scala.meta.Tree = this.privateCopy$default$3;
        <artifact> val x$1927: scala.meta.internal.semantic.Environment = this.privateCopy$default$5;
        <artifact> val x$1928: scala.meta.internal.semantic.Denotation = this.privateCopy$default$6;
        <artifact> val x$1929: scala.meta.internal.semantic.Typing = this.privateCopy$default$7;
        <artifact> val x$1930: scala.meta.internal.ffi.Ffi = this.privateCopy$default$8;
        this.privateCopy(x$1924, x$1925, x$1926, x$1923, x$1927, x$1928, x$1929, x$1930)
      };
      def inheritTokens(other: scala.meta.Tree): scala.meta.Term.If.Quasi = {
        <artifact> val x$1931: scala.meta.tokens.Tokens = other.tokens;
        <artifact> val x$1932: meta.internal.flags.Flags = this.privateCopy$default$1;
        <artifact> val x$1933: scala.meta.Tree = this.privateCopy$default$2;
        <artifact> val x$1934: scala.meta.Tree = this.privateCopy$default$3;
        <artifact> val x$1935: scala.meta.internal.semantic.Environment = this.privateCopy$default$5;
        <artifact> val x$1936: scala.meta.internal.semantic.Denotation = this.privateCopy$default$6;
        <artifact> val x$1937: scala.meta.internal.semantic.Typing = this.privateCopy$default$7;
        <artifact> val x$1938: scala.meta.internal.ffi.Ffi = this.privateCopy$default$8;
        this.privateCopy(x$1932, x$1933, x$1934, x$1931, x$1935, x$1936, x$1937, x$1938)
      };
      override type ThisType = scala.meta.Term.If.Quasi;
      override def privateTag: Int = If.this.Quasi.privateTag;
      override def productPrefix: String = ("Term.If.Quasi": String);
      override def productArity: Int = 2;
      override def productElement(n: Int): Any = n match {
        case 0 => this.rank
        case 1 => this.tree
        case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
      };
      override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
    };
    @SerialVersionUID(value = 1L) final private[Quasi] class Impl extends AnyRef with scala.meta.Term.If.Quasi.Api {
      <paramaccessor> private[this] val privateFlags: meta.internal.flags.Flags = _;
      <stable> <accessor> <paramaccessor> protected def privateFlags: meta.internal.flags.Flags = Impl.this.privateFlags;
      @transient <paramaccessor> private[this] val privatePrototype: scala.meta.Term.If.Quasi = _;
      <stable> <accessor> <paramaccessor> protected def privatePrototype: scala.meta.Term.If.Quasi = Impl.this.privatePrototype;
      <paramaccessor> private[this] val privateParent: scala.meta.Tree = _;
      <stable> <accessor> <paramaccessor> protected def privateParent: scala.meta.Tree = Impl.this.privateParent;
      @transient <paramaccessor> private[this] var privateTokens: scala.meta.tokens.Tokens = _;
      <accessor> <paramaccessor> protected def privateTokens: scala.meta.tokens.Tokens = Impl.this.privateTokens;
      <accessor> <paramaccessor> protected def privateTokens_=(x$1: scala.meta.tokens.Tokens): Unit = Impl.this.privateTokens = x$1;
      <paramaccessor> private[this] var _rank: Int = _;
      <accessor> <paramaccessor> def _rank: Int = Impl.this._rank;
      <accessor> <paramaccessor> def _rank_=(x$1: Int): Unit = Impl.this._rank = x$1;
      <paramaccessor> private[this] var _tree: Any = _;
      <accessor> <paramaccessor> def _tree: Any = Impl.this._tree;
      <accessor> <paramaccessor> def _tree_=(x$1: Any): Unit = Impl.this._tree = x$1;
      def <init>(privateFlags: meta.internal.flags.Flags, privatePrototype: scala.meta.Term.If.Quasi, privateParent: scala.meta.Tree, privateTokens: scala.meta.tokens.Tokens)(_rank: Int, _tree: Any): scala.meta.Term.If.Quasi.Impl = {
        Impl.super.<init>();
        ()
      };
      def parent: Option[scala.meta.Tree] = if (Impl.this.privateParent.!=(null))
        scala.Some.apply[scala.meta.Tree](Impl.this.privateParent)
      else
        scala.None;
      def children: scala.collection.immutable.Seq[scala.meta.Tree] = (immutable.this.Nil: scala.collection.immutable.Seq[scala.meta.Tree]);
      def tokens: scala.meta.tokens.Tokens = {
        Impl.this.privateTokens_=(Impl.this.privateTokens match {
          case null => scala.meta.internal.prettyprinters.inferTokens.apply(this, scala.None)
          case (prototype: scala.meta.Tree)scala.meta.internal.tokens.TransformedTokens((proto @ _)) => scala.meta.internal.prettyprinters.inferTokens.apply(this, scala.Some.apply[scala.meta.Tree](proto))
          case (other @ _) => other
        });
        Impl.this.privateTokens
      };
      def rank: Int = {
        ((): Unit);
        this._rank
      };
      def tree: Any = {
        ((): Unit);
        this._tree
      };
      private[meta] def privateCopy(flags: meta.internal.flags.Flags = Impl.this.privateFlags, prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.privateParent, tokens: scala.meta.tokens.Tokens = Impl.this.privateTokens, env: scala.meta.internal.semantic.Environment = Impl.this.privateEnv, denot: scala.meta.internal.semantic.Denotation = Impl.this.privateDenot, typing: scala.meta.internal.semantic.Typing = Impl.this.privateTyping, ffi: scala.meta.internal.ffi.Ffi = Impl.this.privateFfi): Impl.this.ThisType = new Quasi.this.Impl(flags, prototype.asInstanceOf[Impl.this.ThisType], parent, tokens)((this._rank: Int), (this._tree: Any));
      override <synthetic> def privateCopy$default$1: meta.internal.flags.Flags = Impl.this.privateFlags;
      override <synthetic> def privateCopy$default$2: scala.meta.Tree = this;
      override <synthetic> def privateCopy$default$3: scala.meta.Tree = Impl.this.privateParent;
      override <synthetic> def privateCopy$default$4: scala.meta.tokens.Tokens = Impl.this.privateTokens;
      override <synthetic> def privateCopy$default$5: scala.meta.internal.semantic.Environment = Impl.this.privateEnv;
      override <synthetic> def privateCopy$default$6: scala.meta.internal.semantic.Denotation = Impl.this.privateDenot;
      override <synthetic> def privateCopy$default$7: scala.meta.internal.semantic.Typing = Impl.this.privateTyping;
      override <synthetic> def privateCopy$default$8: scala.meta.internal.ffi.Ffi = Impl.this.privateFfi;
      protected def writeReplace(): AnyRef = {
        ((): Unit);
        ((): Unit);
        this
      };
      def become[T <: scala.meta.internal.ast.Quasi](implicit ev: scala.meta.internal.ast.AstInfo[T]): T = this match {
        case If.this.Quasi.unapply(<unapply-selector>) <unapply> (0, (tree @ _)) => ev.quasi(0, tree).withTokens(this.tokens).asInstanceOf[T]
        case If.this.Quasi.unapply(<unapply-selector>) <unapply> (1, (nested @ If.this.Quasi.unapply(<unapply-selector>) <unapply> (0, (tree @ _)))) => ev.quasi(1, nested.become[T](ev)).withTokens(this.tokens).asInstanceOf[T]
        case _ => throw new scala.`package`.Exception("complex ellipses are not supported yet")
      }
    };
    <synthetic> private def readResolve(): Object = If.this.Quasi
  };
  <synthetic> private def readResolve(): Object = Term.this.If
};
```
