We use macro annotations to generate swaths of boilerplate that are required for our abstract syntax trees
to be efficient and convenient. Here's the code that we write in [Trees.scala](/reflection/core/Trees.scala):

```
@ast class This(qual: Option[core.Name]) extends Ref with Mod.AccessQualifier
```

Here's the code generated by the `@ast` macro annotation:

```
@_root_.org.scalareflect.adt.Internal.leaf final class This private (
  // part 1: payload (qual) along with several bookkeeping fields
  private var internalQual: Option[core.Name],
  private val prototype: This,
  val parent: Tree,
  private[reflect] val scratchpad: Any,
  val origin: _root_.scala.reflect.core.Origin
) extends Ref with Mod.AccessQualifier with _root_.scala.Product {
  // part 2: getters and setters for the payload
  import scala.language.experimental.macros;
  def qual: Option[core.Name] = {
    _root_.org.scalareflect.annotations.internal.ast.loadField(this.internalQual);
    this.internalQual
  };
  def qual_=(x: Tree): Unit = macro _root_.org.scalareflect.annotations.internal.ast.AstHelperMacros.payloadIsImmutable;
  def withQual(qual: Option[core.Name])(implicit origin: _root_.scala.reflect.core.Origin): ThisType = this.copy(qual = qual);
  def mapQual(f: _root_.scala.Function1[Option[core.Name], Option[core.Name]])(implicit origin: _root_.scala.reflect.core.Origin): ThisType = this.copy(qual = f(this.qual));
  def copy(qual: Option[core.Name] = this.qual)(implicit origin: _root_.scala.reflect.core.Origin): ThisType = This.apply(qual)(_root_.scala.reflect.core.Origin.Transform(this, this.origin));

  // part 3: getters and setters for bookkeeping fields
  private[reflect] def internalWithParent(parent: Tree): ThisType = new ThisType(_root_.org.scalareflect.annotations.internal.ast.initField(this.internalQual), this, parent, scratchpad, origin);
  private[reflect] def withScratchpad(scratchpad: Any): ThisType = new ThisType(_root_.org.scalareflect.annotations.internal.ast.initField(this.internalQual), this, parent, scratchpad, origin);
  private[reflect] def mapScratchpad(f: _root_.scala.Function1[Any, Any]): ThisType = new ThisType(_root_.org.scalareflect.annotations.internal.ast.initField(this.internalQual), this, parent, f(scratchpad), origin);
  def withOrigin(origin: Origin): ThisType = new ThisType(_root_.org.scalareflect.annotations.internal.ast.initField(this.internalQual), this, parent, scratchpad, origin);
  def mapOrigin(f: _root_.scala.Function1[Origin, Origin]): ThisType = new ThisType(_root_.org.scalareflect.annotations.internal.ast.initField(this.internalQual), this, parent, scratchpad, f(origin));

  // part 4: advanced caseclass-like functionality
  override type ThisType = This;
  private[reflect] def tag: _root_.scala.Int = _root_.org.scalareflect.adt.Internal.calculateTag[ThisType];
  _root_.org.scalareflect.adt.Internal.hierarchyCheck[ThisType];

  // part 5: standard caseclass-like functionality
  override def productPrefix: _root_.scala.Predef.String = "This";
  override def productArity: _root_.scala.Int = 1;
  override def productElement(n: _root_.scala.Int): Any = n match {
    case 0 => this.qual
    case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
  };
  override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this);
  override def canEqual(that: _root_.scala.Any): _root_.scala.Boolean = that.isInstanceOf[ThisType];
  override def equals(that: _root_.scala.Any): _root_.scala.Boolean = this.eq(that.asInstanceOf[AnyRef]).||(semanticallyEqual(that).&&(structurallyEqual(that)));
  private def semanticallyEqual(that: _root_.scala.Any): _root_.scala.Boolean = false;
  private def structurallyEqual(that: _root_.scala.Any): _root_.scala.Boolean = that match {
    case (that @ ((_): ThisType)) => this.qual.==(that.qual).&&(true)
    case _ => false
  };
  override def hashCode: _root_.scala.Int = semanticHashCode.^(structuralHashCode);
  private def semanticHashCode: _root_.scala.Int = _root_.java.lang.System.identityHashCode(this);
  private def structuralHashCode: _root_.scala.Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
}
@_root_.org.scalareflect.adt.Internal.leaf object This {
  def apply(qual: Option[core.Name])(implicit origin: _root_.scala.reflect.core.Origin): This = {
    _root_.org.scalareflect.adt.Internal.nullCheck(qual);
    _root_.org.scalareflect.adt.Internal.emptyCheck(qual);
    val node = new This(_root_.org.scalareflect.annotations.internal.ast.initParam(qual), prototype = null, parent = _root_.scala.reflect.core.root, scratchpad = null, origin = origin);
    _root_.org.scalareflect.annotations.internal.ast.storeField(node.internalQual, qual);
    node
  };
  def unapply(x: This): Option[Option[core.Name]] = if (x.==(null))
    _root_.scala.None
  else
    _root_.scala.Some(x.qual)
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@org.scalareflect.adt.Internal.leaf final class This extends AnyRef with scala.reflect.core.Term.Ref with scala.reflect.core.Mod.AccessQualifier with Product {
  <paramaccessor> private[this] var internalQual: Option[scala.reflect.core.Name] = _;
  <accessor> <paramaccessor> private def internalQual: Option[scala.reflect.core.Name] = This.this.internalQual;
  <accessor> <paramaccessor> private def internalQual_=(x$1: Option[scala.reflect.core.Name]): Unit = This.this.internalQual = x$1;
  <paramaccessor> private[this] val prototype: scala.reflect.core.Term.This = _;
  <stable> <accessor> <paramaccessor> private def prototype: scala.reflect.core.Term.This = This.this.prototype;
  <paramaccessor> private[this] val parent: scala.reflect.core.Tree = _;
  <stable> <accessor> <paramaccessor> def parent: scala.reflect.core.Tree = This.this.parent;
  <paramaccessor> private[this] val scratchpad: Any = _;
  <stable> <accessor> <paramaccessor> private[reflect] def scratchpad: Any = This.this.scratchpad;
  <paramaccessor> private[this] val origin: reflect.core.Origin = _;
  <stable> <accessor> <paramaccessor> def origin: reflect.core.Origin = This.this.origin;
  private def <init>(internalQual: Option[scala.reflect.core.Name], prototype: scala.reflect.core.Term.This, parent: scala.reflect.core.Tree, scratchpad: Any, origin: reflect.core.Origin): scala.reflect.core.Term.This = {
    This.super.<init>();
    ()
  };
  import scala.language.experimental.macros;
  def qual: Option[scala.reflect.core.Name] = {
    (if (this.internalQual.==(null))
      this.internalQual_=(this.prototype.internalQual.map[scala.reflect.core.Name#ThisType](((x$10: scala.reflect.core.Name) => x$10.internalWithParent(this))))
    else
      (): Unit);
    this.internalQual
  };
  @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalareflect.annotations.package$internal$ast$AstHelperMacros", "methodName" = "payloadIsImmutable", "signature" = List(List(-3)))) <macro> def qual_=(x: scala.reflect.core.Tree): Unit = new org.scalareflect.annotations.`package`.internal.ast.AstHelperMacros(???).payloadIsImmutable;
  def withQual(qual: Option[scala.reflect.core.Name])(implicit origin: reflect.core.Origin): This.this.ThisType = this.copy(qual)(origin);
  def mapQual(f: Option[scala.reflect.core.Name] => Option[scala.reflect.core.Name])(implicit origin: reflect.core.Origin): This.this.ThisType = this.copy(f.apply(this.qual))(origin);
  def copy(qual: Option[scala.reflect.core.Name] = this.qual)(implicit origin: reflect.core.Origin): This.this.ThisType = Term.this.This.apply(qual)(scala.reflect.core.`package`.Origin.Transform.apply(this, this.origin));
  <synthetic> def copy$default$1: Option[scala.reflect.core.Name] = this.qual;
  private[reflect] def internalWithParent(parent: scala.reflect.core.Tree): This.this.ThisType = new This.this.ThisType((null: Option[scala.reflect.core.Name]), this, parent, This.this.scratchpad, This.this.origin);
  private[reflect] def withScratchpad(scratchpad: Any): This.this.ThisType = new This.this.ThisType((null: Option[scala.reflect.core.Name]), this, This.this.parent, scratchpad, This.this.origin);
  private[reflect] def mapScratchpad(f: Any => Any): This.this.ThisType = new This.this.ThisType((null: Option[scala.reflect.core.Name]), this, This.this.parent, f.apply(This.this.scratchpad), This.this.origin);
  def withOrigin(origin: scala.reflect.core.Origin): This.this.ThisType = new This.this.ThisType((null: Option[scala.reflect.core.Name]), this, This.this.parent, This.this.scratchpad, origin);
  def mapOrigin(f: scala.reflect.core.Origin => scala.reflect.core.Origin): This.this.ThisType = new This.this.ThisType((null: Option[scala.reflect.core.Name]), this, This.this.parent, This.this.scratchpad, f.apply(This.this.origin));
  override type ThisType = scala.reflect.core.Term.This;
  private[reflect] def tag: Int = 1;
  <empty>;
  override def productPrefix: String = "This";
  override def productArity: Int = 1;
  override def productElement(n: Int): Any = n match {
    case 0 => this.qual
    case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
  };
  override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this);
  override def canEqual(that: Any): Boolean = that.isInstanceOf[This.this.ThisType];
  override def equals(that: Any): Boolean = this.eq(that.asInstanceOf[AnyRef]).||(This.this.semanticallyEqual(that).&&(This.this.structurallyEqual(that)));
  private def semanticallyEqual(that: Any): Boolean = false;
  private def structurallyEqual(that: Any): Boolean = that match {
    case (that @ (_: This.this.ThisType)) => this.qual.==(that.qual).&&(true)
    case _ => false
  };
  override def hashCode: Int = This.this.semanticHashCode.^(This.this.structuralHashCode);
  private def semanticHashCode: Int = java.lang.System.identityHashCode(this);
  private def structuralHashCode: Int = scala.runtime.ScalaRunTime._hashCode(this)
};
@@<?> object This extends scala.AnyRef {
  def <init>(): scala.reflect.core.Term.This.type = {
    This.super.<init>();
    ()
  };
  def apply(qual: Option[scala.reflect.core.Name])(implicit origin: reflect.core.Origin): scala.reflect.core.Term.This = {
    ({
      val result$macro$14: Boolean = qual.!=(null);
      if (result$macro$14)
        scala.Tuple2.apply[Boolean, scala.collection.immutable.Nil.type](true, immutable.this.Nil)
      else
        scala.Tuple2.apply[Boolean, List[String]](false, immutable.this.List.apply[String]("qual is equal to null"))
    } match {
      case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
      case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$13 @ _)) => {
        org.scalareflect.invariants.InvariantFailedException.raise("qual.!=(null)", failures$macro$13, scala.Some.apply[scala.reflect.core.Term.This.type](This.this));
        ()
      }
    }: Unit);
    <empty>;
    val node: scala.reflect.core.Term.This = new Term.this.This((null: Option[scala.reflect.core.Name]), null, null, null, origin);
    (node.internalQual_=(qual.map[scala.reflect.core.Name#ThisType](((x$11: scala.reflect.core.Name) => x$11.internalWithParent(node)))): Unit);
    node
  };
  def unapply(x: scala.reflect.core.Term.This): Option[Option[scala.reflect.core.Name]] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[Option[scala.reflect.core.Name]](x.qual)
};
```