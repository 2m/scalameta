### Internal structure of scala.meta ASTs

We use macro annotations to generate swaths of boilerplate that make our abstract syntax trees efficient and convenient.
Here's the code that we write in [Trees.scala](/scalameta/src/main/scala/scala/meta/Trees.scala):

```
@ast class If(cond: Term, thenp: Term, elsep: Term) extends Term
```

Here's the code generated by the `@ast` macro annotation:

```
@new _root_.org.scalameta.ast.internal.astClass() @new _root_.org.scalameta.adt.Internal.leafClass() abstract trait If extends Term with _root_.scala.Product {
  @new _root_.org.scalameta.ast.internal.astField() def cond: Term;
  @new _root_.org.scalameta.ast.internal.astField() def thenp: Term;
  @new _root_.org.scalameta.ast.internal.astField() def elsep: Term;
  override type ThisType <: If
}
@new _root_.org.scalameta.ast.internal.astCompanion() @new _root_.org.scalameta.adt.Internal.leafCompanion() object If extends scala.AnyRef {
  def <init>() = {
    super.<init>();
    ()
  };
  def internalTag: _root_.scala.Int = _root_.org.scalameta.adt.Internal.calculateTag[If];
  def apply(cond: Term, thenp: Term, elsep: Term): If = {
    def internal(cond: Term, thenp: Term, elsep: Term): If = {
      _root_.org.scalameta.ast.internal.hierarchyCheck[If];
      _root_.org.scalameta.adt.Internal.nullCheck(cond);
      _root_.org.scalameta.adt.Internal.nullCheck(thenp);
      _root_.org.scalameta.adt.Internal.nullCheck(elsep);
      _root_.org.scalameta.adt.Internal.emptyCheck(cond);
      _root_.org.scalameta.adt.Internal.emptyCheck(thenp);
      _root_.org.scalameta.adt.Internal.emptyCheck(elsep);
      val node = new Impl(null, null, null, null, null)(_root_.org.scalameta.ast.internal.initParam(cond), _root_.org.scalameta.ast.internal.initParam(thenp), _root_.org.scalameta.ast.internal.initParam(elsep));
      _root_.org.scalameta.ast.internal.storeField(node._cond, cond);
      _root_.org.scalameta.ast.internal.storeField(node._thenp, thenp);
      _root_.org.scalameta.ast.internal.storeField(node._elsep, elsep);
      node
    };
    internal(cond, thenp, elsep)
  };
  @new _root_.scala.inline() final def unapply(x: If): Option[scala.Tuple3[Term, Term, Term]] = if (x.$eq$eq(null))
    _root_.scala.None
  else
    _root_.scala.Some(scala.Tuple3(x.cond, x.thenp, x.elsep));
  import _root_.scala.language.experimental.{macros=>prettyPlease};
  import _root_.scala.language.implicitConversions;
  implicit <macro> def interfaceToApi(interface: If): Api = _root_.org.scalameta.ast.internal.Macros.interfaceToApi[If, Api];
  abstract trait Api extends If {
    def $init$() = {
      ()
    };
    def tokens: _root_.scala.meta.Tokens;
    def typing: _root_.scala.meta.internal.semantic.Typing;
    def expansion: _root_.scala.meta.internal.semantic.Expansion;
    def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep): If = If.apply(cond, thenp, elsep).withTokens(tokens = _root_.scala.meta.internal.ui.TransformedTokens(this));
    def withTokens(tokens: _root_.scala.meta.Tokens): If = this.internalCopy(tokens = tokens);
    def withTyping(typing: _root_.scala.meta.internal.semantic.Typing): If = this.internalCopy(typing = typing);
    def withExpansion(expansion: _root_.scala.meta.internal.semantic.Expansion): If = this.internalCopy(expansion = expansion);
    override type ThisType = If;
    override def internalTag: _root_.scala.Int = If.internalTag;
    override def productPrefix: _root_.scala.Predef.String = _root_.org.scalameta.ast.internal.productPrefix[ThisType];
    override def productArity: _root_.scala.Int = 3;
    override def productElement(n: _root_.scala.Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
    };
    override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this)
  };
  final private[If] class Impl extends Api {
    @new _root_.scala.transient() <paramaccessor> protected val internalPrototype: If = _;
    <paramaccessor> protected val internalParent: _root_.scala.meta.Tree = _;
    @new _root_.scala.transient() <paramaccessor> protected var internalTokens: _root_.scala.meta.Tokens = _;
    <paramaccessor> protected val internalTyping: _root_.scala.meta.internal.semantic.Typing = _;
    <paramaccessor> protected val internalExpansion: _root_.scala.meta.internal.semantic.Expansion = _;
    <paramaccessor> var _cond: Term = _;
    <paramaccessor> var _thenp: Term = _;
    <paramaccessor> var _elsep: Term = _;
    def <init>(@new _root_.scala.transient() internalPrototype: If, internalParent: _root_.scala.meta.Tree, @new _root_.scala.transient() internalTokens: _root_.scala.meta.Tokens, internalTyping: _root_.scala.meta.internal.semantic.Typing, internalExpansion: _root_.scala.meta.internal.semantic.Expansion)(_cond: Term, _thenp: Term, _elsep: Term) = {
      super.<init>();
      ()
    };
    def parent: _root_.scala.Option[_root_.scala.meta.Tree] = if (internalParent.$bang$eq(null))
      _root_.scala.Some(internalParent)
    else
      _root_.scala.None;
    def tokens: _root_.scala.meta.Tokens = {
      internalTokens = internalTokens match {
        case null => _root_.scala.meta.internal.ui.inferTokens(this, None)
        case _root_.scala.meta.internal.ui.TransformedTokens((proto @ _)) => _root_.scala.meta.internal.ui.inferTokens(this, Some(proto))
        case (other @ _) => other
      };
      internalTokens
    };
    protected def internalEnv: _root_.scala.meta.semantic.Environment = null;
    protected def internalDenot: _root_.scala.meta.internal.semantic.Denotation = null;
    def typing: _root_.scala.meta.internal.semantic.Typing = if (internalTyping.$bang$eq(null))
      internalTyping
    else
      _root_.scala.meta.internal.semantic.Typing.Zero;
    def expansion: _root_.scala.meta.internal.semantic.Expansion = if (internalExpansion.$bang$eq(null))
      internalExpansion
    else
      _root_.scala.meta.internal.semantic.Expansion.Zero;
    def cond: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._cond);
      this._cond
    };
    def thenp: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._thenp);
      this._thenp
    };
    def elsep: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._elsep);
      this._elsep
    };
    private[meta] def internalCopy(prototype: _root_.scala.meta.Tree = this, parent: _root_.scala.meta.Tree = internalParent, tokens: _root_.scala.meta.Tokens = internalTokens, env: _root_.scala.meta.semantic.Environment = internalEnv, denot: _root_.scala.meta.internal.semantic.Denotation = internalDenot, typing: _root_.scala.meta.internal.semantic.Typing = internalTyping, expansion: _root_.scala.meta.internal.semantic.Expansion = internalExpansion): ThisType = new Impl(prototype.asInstanceOf[ThisType], parent, tokens, typing, expansion)(_root_.org.scalameta.ast.internal.initField(this._cond), _root_.org.scalameta.ast.internal.initField(this._thenp), _root_.org.scalameta.ast.internal.initField(this._elsep));
    protected def writeReplace(): _root_.scala.AnyRef = {
      _root_.org.scalameta.ast.internal.loadField(this._cond);
      _root_.org.scalameta.ast.internal.loadField(this._thenp);
      _root_.org.scalameta.ast.internal.loadField(this._elsep);
      this
    }
  };
  @new _root_.org.scalameta.ast.ast() private[meta] class Quasi extends If with _root_.scala.meta.internal.ast.Quasi with Term.Quasi {
    <paramaccessor> private[this] val rank: _root_.scala.Int = _;
    <paramaccessor> private[this] val tree: _root_.scala.Any = _;
    def <init>(rank: _root_.scala.Int, tree: _root_.scala.Any) = {
      super.<init>();
      ()
    };
    override protected def internalEnv: _root_.scala.meta.semantic.Environment = null;
    override protected def internalDenot: _root_.scala.meta.internal.semantic.Denotation = null;
    override def typing: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override protected def internalTyping: _root_.scala.meta.internal.semantic.Typing = null;
    override def expansion: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override protected def internalExpansion: _root_.scala.meta.internal.semantic.Expansion = null;
    override def cond: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override def thenp: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override def elsep: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override def withTyping(typing: _root_.scala.meta.internal.semantic.Typing): _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override def withExpansion(expansion: _root_.scala.meta.internal.semantic.Expansion): _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def pt: _root_.java.lang.Class[_$62] forSome {
      <synthetic> type _$62
    } = _root_.org.scalameta.runtime.arrayClass(_root_.scala.Predef.classOf[If], this.rank)
  }
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass abstract trait If extends AnyRef with scala.meta.internal.ast.Term with Product {
  @org.scalameta.ast.internal.astField def cond: scala.meta.internal.ast.Term;
  @org.scalameta.ast.internal.astField def thenp: scala.meta.internal.ast.Term;
  @org.scalameta.ast.internal.astField def elsep: scala.meta.internal.ast.Term;
  override type ThisType <: scala.meta.internal.ast.Term.If
};
@@<?> @@<?> object If extends scala.AnyRef with Serializable {
  def <init>(): scala.meta.internal.ast.Term.If.type = {
    If.super.<init>();
    ()
  };
  def internalTag: Int = 87;
  def apply(cond: scala.meta.internal.ast.Term, thenp: scala.meta.internal.ast.Term, elsep: scala.meta.internal.ast.Term): scala.meta.internal.ast.Term.If = {
    def internal(cond: scala.meta.internal.ast.Term, thenp: scala.meta.internal.ast.Term, elsep: scala.meta.internal.ast.Term): scala.meta.internal.ast.Term.If = {
      ((): Unit);
      ({
        val result$macro$292: Boolean = cond.!=(null);
        if (result$macro$292)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("cond is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$291 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("cond.!=(null)", failures$macro$291, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("cond", cond)))
      }: Unit);
      ({
        val result$macro$294: Boolean = thenp.!=(null);
        if (result$macro$294)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("thenp is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$293 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("thenp.!=(null)", failures$macro$293, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("thenp", thenp)))
      }: Unit);
      ({
        val result$macro$296: Boolean = elsep.!=(null);
        if (result$macro$296)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("elsep is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$295 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("elsep.!=(null)", failures$macro$295, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("elsep", elsep)))
      }: Unit);
      ();
      ();
      ();
      val node: scala.meta.internal.ast.Term.If.Impl = new If.this.Impl(null, null, null, null, null)((null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term));
      (node._cond_=(cond.internalCopy(cond, node, cond.internalCopy$default$3, cond.internalCopy$default$4, cond.internalCopy$default$5, cond.internalCopy$default$6, cond.internalCopy$default$7)): Unit);
      (node._thenp_=(thenp.internalCopy(thenp, node, thenp.internalCopy$default$3, thenp.internalCopy$default$4, thenp.internalCopy$default$5, thenp.internalCopy$default$6, thenp.internalCopy$default$7)): Unit);
      (node._elsep_=(elsep.internalCopy(elsep, node, elsep.internalCopy$default$3, elsep.internalCopy$default$4, elsep.internalCopy$default$5, elsep.internalCopy$default$6, elsep.internalCopy$default$7)): Unit);
      node
    };
    internal(cond, thenp, elsep)
  };
  @inline final def unapply(x: scala.meta.internal.ast.Term.If): Option[(scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term)] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[(scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term)](scala.Tuple3.apply[scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term](x.cond, x.thenp, x.elsep));
  import scala.language.experimental.{macros=>prettyPlease};
  import scala.language.implicitConversions;
  @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalameta.ast.internal$Macros", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.internal.ast.Term.If, scala.meta.internal.ast.Term.If.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.internal.ast.Term.If): scala.meta.internal.ast.Term.If.Api = new org.scalameta.ast.internal.Macros(null).interfaceToApi[scala.meta.internal.ast.Term.If, scala.meta.internal.ast.Term.If.Api];
  abstract trait Api extends AnyRef with scala.meta.internal.ast.Term.If {
    def /*Api*/$init$(): Unit = {
      ()
    };
    def tokens: meta.Tokens;
    def typing: scala.meta.internal.semantic.Typing;
    def expansion: scala.meta.internal.semantic.Expansion;
    def copy(cond: scala.meta.internal.ast.Term = this.cond, thenp: scala.meta.internal.ast.Term = this.thenp, elsep: scala.meta.internal.ast.Term = this.elsep): scala.meta.internal.ast.Term.If = Term.this.If.apply(cond, thenp, elsep).withTokens(scala.meta.internal.ui.TransformedTokens.apply(this));
    <synthetic> def copy$default$1: scala.meta.internal.ast.Term = this.cond;
    <synthetic> def copy$default$2: scala.meta.internal.ast.Term = this.thenp;
    <synthetic> def copy$default$3: scala.meta.internal.ast.Term = this.elsep;
    def withTokens(tokens: meta.Tokens): scala.meta.internal.ast.Term.If = {
      <artifact> val x$1255: meta.Tokens = tokens;
      <artifact> val x$1256: scala.meta.Tree = this.internalCopy$default$1;
      <artifact> val x$1257: scala.meta.Tree = this.internalCopy$default$2;
      <artifact> val x$1258: scala.meta.semantic.Environment = this.internalCopy$default$4;
      <artifact> val x$1259: scala.meta.internal.semantic.Denotation = this.internalCopy$default$5;
      <artifact> val x$1260: scala.meta.internal.semantic.Typing = this.internalCopy$default$6;
      <artifact> val x$1261: scala.meta.internal.semantic.Expansion = this.internalCopy$default$7;
      this.internalCopy(x$1256, x$1257, x$1255, x$1258, x$1259, x$1260, x$1261)
    };
    def withTyping(typing: scala.meta.internal.semantic.Typing): scala.meta.internal.ast.Term.If = {
      <artifact> val x$1262: scala.meta.internal.semantic.Typing = typing;
      <artifact> val x$1263: scala.meta.Tree = this.internalCopy$default$1;
      <artifact> val x$1264: scala.meta.Tree = this.internalCopy$default$2;
      <artifact> val x$1265: meta.Tokens = this.internalCopy$default$3;
      <artifact> val x$1266: scala.meta.semantic.Environment = this.internalCopy$default$4;
      <artifact> val x$1267: scala.meta.internal.semantic.Denotation = this.internalCopy$default$5;
      <artifact> val x$1268: scala.meta.internal.semantic.Expansion = this.internalCopy$default$7;
      this.internalCopy(x$1263, x$1264, x$1265, x$1266, x$1267, x$1262, x$1268)
    };
    def withExpansion(expansion: scala.meta.internal.semantic.Expansion): scala.meta.internal.ast.Term.If = {
      <artifact> val x$1269: scala.meta.internal.semantic.Expansion = expansion;
      <artifact> val x$1270: scala.meta.Tree = this.internalCopy$default$1;
      <artifact> val x$1271: scala.meta.Tree = this.internalCopy$default$2;
      <artifact> val x$1272: meta.Tokens = this.internalCopy$default$3;
      <artifact> val x$1273: scala.meta.semantic.Environment = this.internalCopy$default$4;
      <artifact> val x$1274: scala.meta.internal.semantic.Denotation = this.internalCopy$default$5;
      <artifact> val x$1275: scala.meta.internal.semantic.Typing = this.internalCopy$default$6;
      this.internalCopy(x$1270, x$1271, x$1272, x$1273, x$1274, x$1275, x$1269)
    };
    override type ThisType = scala.meta.internal.ast.Term.If;
    override def internalTag: Int = Term.this.If.internalTag;
    override def productPrefix: String = ("Term.If": String);
    override def productArity: Int = 3;
    override def productElement(n: Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
    };
    override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
  };
  final private[If] class Impl extends AnyRef with scala.meta.internal.ast.Term.If.Api {
    @transient <paramaccessor> private[this] val internalPrototype: scala.meta.internal.ast.Term.If = _;
    <stable> <accessor> <paramaccessor> protected def internalPrototype: scala.meta.internal.ast.Term.If = Impl.this.internalPrototype;
    <paramaccessor> private[this] val internalParent: scala.meta.Tree = _;
    <stable> <accessor> <paramaccessor> protected def internalParent: scala.meta.Tree = Impl.this.internalParent;
    @transient <paramaccessor> private[this] var internalTokens: meta.Tokens = _;
    <accessor> <paramaccessor> protected def internalTokens: meta.Tokens = Impl.this.internalTokens;
    <accessor> <paramaccessor> protected def internalTokens_=(x$1: meta.Tokens): Unit = Impl.this.internalTokens = x$1;
    <paramaccessor> private[this] val internalTyping: scala.meta.internal.semantic.Typing = _;
    <stable> <accessor> <paramaccessor> protected def internalTyping: scala.meta.internal.semantic.Typing = Impl.this.internalTyping;
    <paramaccessor> private[this] val internalExpansion: scala.meta.internal.semantic.Expansion = _;
    <stable> <accessor> <paramaccessor> protected def internalExpansion: scala.meta.internal.semantic.Expansion = Impl.this.internalExpansion;
    <paramaccessor> private[this] var _cond: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _cond: scala.meta.internal.ast.Term = Impl.this._cond;
    <accessor> <paramaccessor> def _cond_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._cond = x$1;
    <paramaccessor> private[this] var _thenp: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _thenp: scala.meta.internal.ast.Term = Impl.this._thenp;
    <accessor> <paramaccessor> def _thenp_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._thenp = x$1;
    <paramaccessor> private[this] var _elsep: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _elsep: scala.meta.internal.ast.Term = Impl.this._elsep;
    <accessor> <paramaccessor> def _elsep_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._elsep = x$1;
    def <init>(internalPrototype: scala.meta.internal.ast.Term.If, internalParent: scala.meta.Tree, internalTokens: meta.Tokens, internalTyping: scala.meta.internal.semantic.Typing, internalExpansion: scala.meta.internal.semantic.Expansion)(_cond: scala.meta.internal.ast.Term, _thenp: scala.meta.internal.ast.Term, _elsep: scala.meta.internal.ast.Term): scala.meta.internal.ast.Term.If.Impl = {
      Impl.super.<init>();
      ()
    };
    def parent: Option[scala.meta.Tree] = if (Impl.this.internalParent.!=(null))
      scala.Some.apply[scala.meta.Tree](Impl.this.internalParent)
    else
      scala.None;
    def tokens: meta.Tokens = {
      Impl.this.internalTokens_=(Impl.this.internalTokens match {
        case null => scala.meta.internal.ui.inferTokens.apply(this, scala.None)
        case (prototype: scala.meta.Tree)scala.meta.internal.ui.TransformedTokens((proto @ _)) => scala.meta.internal.ui.inferTokens.apply(this, scala.Some.apply[scala.meta.Tree](proto))
        case (other @ _) => other
      });
      Impl.this.internalTokens
    };
    protected def internalEnv: scala.meta.semantic.Environment = null;
    protected def internalDenot: scala.meta.internal.semantic.Denotation = null;
    def typing: scala.meta.internal.semantic.Typing = if (Impl.this.internalTyping.!=(null))
      Impl.this.internalTyping
    else
      scala.meta.internal.semantic.Typing.Zero;
    def expansion: scala.meta.internal.semantic.Expansion = if (Impl.this.internalExpansion.!=(null))
      Impl.this.internalExpansion
    else
      scala.meta.internal.semantic.Expansion.Zero;
    def cond: scala.meta.internal.ast.Term = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.cond");
          this._cond_=({
            <artifact> val qual$43: scala.meta.internal.ast.Term = this.internalPrototype.cond;
            <artifact> val x$1276: scala.meta.internal.ast.Term = this.internalPrototype.cond;
            <artifact> val x$1277: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$1278: meta.Tokens = qual$43.internalCopy$default$3;
            <artifact> val x$1279: scala.meta.semantic.Environment = qual$43.internalCopy$default$4;
            <artifact> val x$1280: scala.meta.internal.semantic.Denotation = qual$43.internalCopy$default$5;
            <artifact> val x$1281: scala.meta.internal.semantic.Typing = qual$43.internalCopy$default$6;
            <artifact> val x$1282: scala.meta.internal.semantic.Expansion = qual$43.internalCopy$default$7;
            qual$43.internalCopy(x$1276, x$1277, x$1278, x$1279, x$1280, x$1281, x$1282)
          })
        }
      else
        (): Unit);
      this._cond
    };
    def thenp: scala.meta.internal.ast.Term = {
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.thenp");
          this._thenp_=({
            <artifact> val qual$44: scala.meta.internal.ast.Term = this.internalPrototype.thenp;
            <artifact> val x$1283: scala.meta.internal.ast.Term = this.internalPrototype.thenp;
            <artifact> val x$1284: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$1285: meta.Tokens = qual$44.internalCopy$default$3;
            <artifact> val x$1286: scala.meta.semantic.Environment = qual$44.internalCopy$default$4;
            <artifact> val x$1287: scala.meta.internal.semantic.Denotation = qual$44.internalCopy$default$5;
            <artifact> val x$1288: scala.meta.internal.semantic.Typing = qual$44.internalCopy$default$6;
            <artifact> val x$1289: scala.meta.internal.semantic.Expansion = qual$44.internalCopy$default$7;
            qual$44.internalCopy(x$1283, x$1284, x$1285, x$1286, x$1287, x$1288, x$1289)
          })
        }
      else
        (): Unit);
      this._thenp
    };
    def elsep: scala.meta.internal.ast.Term = {
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.elsep");
          this._elsep_=({
            <artifact> val qual$45: scala.meta.internal.ast.Term = this.internalPrototype.elsep;
            <artifact> val x$1290: scala.meta.internal.ast.Term = this.internalPrototype.elsep;
            <artifact> val x$1291: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$1292: meta.Tokens = qual$45.internalCopy$default$3;
            <artifact> val x$1293: scala.meta.semantic.Environment = qual$45.internalCopy$default$4;
            <artifact> val x$1294: scala.meta.internal.semantic.Denotation = qual$45.internalCopy$default$5;
            <artifact> val x$1295: scala.meta.internal.semantic.Typing = qual$45.internalCopy$default$6;
            <artifact> val x$1296: scala.meta.internal.semantic.Expansion = qual$45.internalCopy$default$7;
            qual$45.internalCopy(x$1290, x$1291, x$1292, x$1293, x$1294, x$1295, x$1296)
          })
        }
      else
        (): Unit);
      this._elsep
    };
    private[meta] def internalCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.internalParent, tokens: meta.Tokens = Impl.this.internalTokens, env: scala.meta.semantic.Environment = Impl.this.internalEnv, denot: scala.meta.internal.semantic.Denotation = Impl.this.internalDenot, typing: scala.meta.internal.semantic.Typing = Impl.this.internalTyping, expansion: scala.meta.internal.semantic.Expansion = Impl.this.internalExpansion): Impl.this.ThisType = new If.this.Impl(prototype.asInstanceOf[Impl.this.ThisType], parent, tokens, typing, expansion)((null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term));
    override <synthetic> def internalCopy$default$1: scala.meta.Tree = this;
    override <synthetic> def internalCopy$default$2: scala.meta.Tree = Impl.this.internalParent;
    override <synthetic> def internalCopy$default$3: meta.Tokens = Impl.this.internalTokens;
    override <synthetic> def internalCopy$default$4: scala.meta.semantic.Environment = Impl.this.internalEnv;
    override <synthetic> def internalCopy$default$5: scala.meta.internal.semantic.Denotation = Impl.this.internalDenot;
    override <synthetic> def internalCopy$default$6: scala.meta.internal.semantic.Typing = Impl.this.internalTyping;
    override <synthetic> def internalCopy$default$7: scala.meta.internal.semantic.Expansion = Impl.this.internalExpansion;
    protected def writeReplace(): AnyRef = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.cond");
          this._cond_=({
            <artifact> val qual$46: scala.meta.internal.ast.Term = this.internalPrototype.cond;
            <artifact> val x$1297: scala.meta.internal.ast.Term = this.internalPrototype.cond;
            <artifact> val x$1298: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$1299: meta.Tokens = qual$46.internalCopy$default$3;
            <artifact> val x$1300: scala.meta.semantic.Environment = qual$46.internalCopy$default$4;
            <artifact> val x$1301: scala.meta.internal.semantic.Denotation = qual$46.internalCopy$default$5;
            <artifact> val x$1302: scala.meta.internal.semantic.Typing = qual$46.internalCopy$default$6;
            <artifact> val x$1303: scala.meta.internal.semantic.Expansion = qual$46.internalCopy$default$7;
            qual$46.internalCopy(x$1297, x$1298, x$1299, x$1300, x$1301, x$1302, x$1303)
          })
        }
      else
        (): Unit);
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.thenp");
          this._thenp_=({
            <artifact> val qual$47: scala.meta.internal.ast.Term = this.internalPrototype.thenp;
            <artifact> val x$1304: scala.meta.internal.ast.Term = this.internalPrototype.thenp;
            <artifact> val x$1305: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$1306: meta.Tokens = qual$47.internalCopy$default$3;
            <artifact> val x$1307: scala.meta.semantic.Environment = qual$47.internalCopy$default$4;
            <artifact> val x$1308: scala.meta.internal.semantic.Denotation = qual$47.internalCopy$default$5;
            <artifact> val x$1309: scala.meta.internal.semantic.Typing = qual$47.internalCopy$default$6;
            <artifact> val x$1310: scala.meta.internal.semantic.Expansion = qual$47.internalCopy$default$7;
            qual$47.internalCopy(x$1304, x$1305, x$1306, x$1307, x$1308, x$1309, x$1310)
          })
        }
      else
        (): Unit);
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.internalPrototype.!=(null), "internal error when initializing Impl.elsep");
          this._elsep_=({
            <artifact> val qual$48: scala.meta.internal.ast.Term = this.internalPrototype.elsep;
            <artifact> val x$1311: scala.meta.internal.ast.Term = this.internalPrototype.elsep;
            <artifact> val x$1312: scala.meta.internal.ast.Term.If.Impl = this;
            <artifact> val x$1313: meta.Tokens = qual$48.internalCopy$default$3;
            <artifact> val x$1314: scala.meta.semantic.Environment = qual$48.internalCopy$default$4;
            <artifact> val x$1315: scala.meta.internal.semantic.Denotation = qual$48.internalCopy$default$5;
            <artifact> val x$1316: scala.meta.internal.semantic.Typing = qual$48.internalCopy$default$6;
            <artifact> val x$1317: scala.meta.internal.semantic.Expansion = qual$48.internalCopy$default$7;
            qual$48.internalCopy(x$1311, x$1312, x$1313, x$1314, x$1315, x$1316, x$1317)
          })
        }
      else
        (): Unit);
      this
    }
  };
  @org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass abstract private[meta] trait Quasi extends AnyRef with scala.meta.internal.ast.Term.If with scala.meta.internal.ast.Quasi with scala.meta.internal.ast.Term.Quasi with Product {
    @org.scalameta.ast.internal.astField def rank: Int;
    @org.scalameta.ast.internal.astField def tree: Any;
    override type ThisType <: scala.meta.internal.ast.Term.If.Quasi
  };
  @@<?> @@<?> private[meta] object Quasi extends scala.AnyRef with Serializable {
    def <init>(): scala.meta.internal.ast.Term.If.Quasi.type = {
      Quasi.super.<init>();
      ()
    };
    def internalTag: Int = 88;
    def apply(rank: Int, tree: Any): scala.meta.internal.ast.Term.If.Quasi = {
      def internal(rank: Int, tree: Any): scala.meta.internal.ast.Term.If.Quasi = {
        ((): Unit);
        ();
        ();
        ();
        ();
        val node: scala.meta.internal.ast.Term.If.Quasi.Impl = new Quasi.this.Impl(null, null, null)((rank: Int), (tree: Any));
        ((): Unit);
        ((): Unit);
        node
      };
      internal(rank, tree)
    };
    @inline final def unapply(x: scala.meta.internal.ast.Term.If.Quasi): Option[(Int, Any)] = if (x.==(null))
      scala.None
    else
      scala.Some.apply[(Int, Any)](scala.Tuple2.apply[Int, Any](x.rank, x.tree));
    import scala.language.experimental.{macros=>prettyPlease};
    import scala.language.implicitConversions;
    @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalameta.ast.internal$Macros", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.internal.ast.Term.If.Quasi, scala.meta.internal.ast.Term.If.Quasi.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.internal.ast.Term.If.Quasi): scala.meta.internal.ast.Term.If.Quasi.Api = new org.scalameta.ast.internal.Macros(null).interfaceToApi[scala.meta.internal.ast.Term.If.Quasi, scala.meta.internal.ast.Term.If.Quasi.Api];
    abstract trait Api extends AnyRef with scala.meta.internal.ast.Term.If.Quasi {
      def /*Api*/$init$(): Unit = {
        ()
      };
      override protected def internalEnv: scala.meta.semantic.Environment = null;
      override protected def internalDenot: scala.meta.internal.semantic.Denotation = null;
      override def typing: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override protected def internalTyping: scala.meta.internal.semantic.Typing = null;
      override def expansion: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override protected def internalExpansion: scala.meta.internal.semantic.Expansion = null;
      override def cond: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override def thenp: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override def elsep: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override def withTyping(typing: scala.meta.internal.semantic.Typing): Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override def withExpansion(expansion: scala.meta.internal.semantic.Expansion): Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def pt: Class[_] = org.scalameta.runtime.`package`.arrayClass(classOf[scala.meta.internal.ast.Term$$If], this.rank);
      def tokens: meta.Tokens;
      def copy(rank: Int = this.rank, tree: Any = this.tree): scala.meta.internal.ast.Term.If.Quasi = If.this.Quasi.apply(rank, tree).withTokens(scala.meta.internal.ui.TransformedTokens.apply(this));
      <synthetic> def copy$default$1: Int = this.rank;
      <synthetic> def copy$default$2: Any = this.tree;
      def withTokens(tokens: meta.Tokens): scala.meta.internal.ast.Term.If.Quasi = {
        <artifact> val x$1318: meta.Tokens = tokens;
        <artifact> val x$1319: scala.meta.Tree = this.internalCopy$default$1;
        <artifact> val x$1320: scala.meta.Tree = this.internalCopy$default$2;
        <artifact> val x$1321: scala.meta.semantic.Environment = this.internalCopy$default$4;
        <artifact> val x$1322: scala.meta.internal.semantic.Denotation = this.internalCopy$default$5;
        <artifact> val x$1323: scala.meta.internal.semantic.Typing = this.internalCopy$default$6;
        <artifact> val x$1324: scala.meta.internal.semantic.Expansion = this.internalCopy$default$7;
        this.internalCopy(x$1319, x$1320, x$1318, x$1321, x$1322, x$1323, x$1324)
      };
      override type ThisType = scala.meta.internal.ast.Term.If.Quasi;
      override def internalTag: Int = If.this.Quasi.internalTag;
      override def productPrefix: String = ("Term.If.Quasi": String);
      override def productArity: Int = 2;
      override def productElement(n: Int): Any = n match {
        case 0 => this.rank
        case 1 => this.tree
        case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
      };
      override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
    };
    final private[Quasi] class Impl extends AnyRef with scala.meta.internal.ast.Term.If.Quasi.Api {
      @transient <paramaccessor> private[this] val internalPrototype: scala.meta.internal.ast.Term.If.Quasi = _;
      <stable> <accessor> <paramaccessor> protected def internalPrototype: scala.meta.internal.ast.Term.If.Quasi = Impl.this.internalPrototype;
      <paramaccessor> private[this] val internalParent: scala.meta.Tree = _;
      <stable> <accessor> <paramaccessor> protected def internalParent: scala.meta.Tree = Impl.this.internalParent;
      @transient <paramaccessor> private[this] var internalTokens: meta.Tokens = _;
      <accessor> <paramaccessor> protected def internalTokens: meta.Tokens = Impl.this.internalTokens;
      <accessor> <paramaccessor> protected def internalTokens_=(x$1: meta.Tokens): Unit = Impl.this.internalTokens = x$1;
      <paramaccessor> private[this] var _rank: Int = _;
      <accessor> <paramaccessor> def _rank: Int = Impl.this._rank;
      <accessor> <paramaccessor> def _rank_=(x$1: Int): Unit = Impl.this._rank = x$1;
      <paramaccessor> private[this] var _tree: Any = _;
      <accessor> <paramaccessor> def _tree: Any = Impl.this._tree;
      <accessor> <paramaccessor> def _tree_=(x$1: Any): Unit = Impl.this._tree = x$1;
      def <init>(internalPrototype: scala.meta.internal.ast.Term.If.Quasi, internalParent: scala.meta.Tree, internalTokens: meta.Tokens)(_rank: Int, _tree: Any): scala.meta.internal.ast.Term.If.Quasi.Impl = {
        Impl.super.<init>();
        ()
      };
      def parent: Option[scala.meta.Tree] = if (Impl.this.internalParent.!=(null))
        scala.Some.apply[scala.meta.Tree](Impl.this.internalParent)
      else
        scala.None;
      def tokens: meta.Tokens = {
        Impl.this.internalTokens_=(Impl.this.internalTokens match {
          case null => scala.meta.internal.ui.inferTokens.apply(this, scala.None)
          case (prototype: scala.meta.Tree)scala.meta.internal.ui.TransformedTokens((proto @ _)) => scala.meta.internal.ui.inferTokens.apply(this, scala.Some.apply[scala.meta.Tree](proto))
          case (other @ _) => other
        });
        Impl.this.internalTokens
      };
      def rank: Int = {
        ((): Unit);
        this._rank
      };
      def tree: Any = {
        ((): Unit);
        this._tree
      };
      private[meta] def internalCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.internalParent, tokens: meta.Tokens = Impl.this.internalTokens, env: scala.meta.semantic.Environment = Impl.this.internalEnv, denot: scala.meta.internal.semantic.Denotation = Impl.this.internalDenot, typing: scala.meta.internal.semantic.Typing = Impl.this.internalTyping, expansion: scala.meta.internal.semantic.Expansion = Impl.this.internalExpansion): Impl.this.ThisType = new Quasi.this.Impl(prototype.asInstanceOf[Impl.this.ThisType], parent, tokens)((this._rank: Int), (this._tree: Any));
      override <synthetic> def internalCopy$default$1: scala.meta.Tree = this;
      override <synthetic> def internalCopy$default$2: scala.meta.Tree = Impl.this.internalParent;
      override <synthetic> def internalCopy$default$3: meta.Tokens = Impl.this.internalTokens;
      override <synthetic> def internalCopy$default$4: scala.meta.semantic.Environment = Impl.this.internalEnv;
      override <synthetic> def internalCopy$default$5: scala.meta.internal.semantic.Denotation = Impl.this.internalDenot;
      override <synthetic> def internalCopy$default$6: scala.meta.internal.semantic.Typing = Impl.this.internalTyping;
      override <synthetic> def internalCopy$default$7: scala.meta.internal.semantic.Expansion = Impl.this.internalExpansion;
      protected def writeReplace(): AnyRef = {
        ((): Unit);
        ((): Unit);
        this
      };
      def become[T <: scala.meta.internal.ast.Quasi](implicit ev: org.scalameta.ast.AstMetadata[T]): T = this match {
        case If.this.Quasi.unapply(<unapply-selector>) <unapply> (0, (tree @ _)) => ev.quasi(0, tree).withTokens(this.tokens).asInstanceOf[T]
        case If.this.Quasi.unapply(<unapply-selector>) <unapply> (1, (nested @ If.this.Quasi.unapply(<unapply-selector>) <unapply> (0, (tree @ _)))) => ev.quasi(1, nested.become[T](ev)).withTokens(this.tokens).asInstanceOf[T]
        case _ => throw new scala.`package`.Exception("complex ellipses are not supported yet")
      }
    };
    <synthetic> private def readResolve(): Object = If.this.Quasi
  };
  <synthetic> private def readResolve(): Object = Term.this.If
};
```
